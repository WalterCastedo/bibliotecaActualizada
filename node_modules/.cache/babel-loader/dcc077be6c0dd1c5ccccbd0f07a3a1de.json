{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { getCurrentInstance, computed } from \"vue\";\nimport { u as useElementRef } from \"../../../composables/useElementRef.js\";\nimport { u as useIntersectionObserver } from \"../../../composables/useIntersectionObserver.js\";\nconst useTableScrollProps = {\n  scrollTopMargin: {\n    type: Number,\n    default: 0\n  },\n  scrollBottomMargin: {\n    type: Number,\n    default: 0\n  }\n};\nconst useTableScrollEmits = [\"scroll:top\", \"scroll:bottom\"];\n\nfunction useTableScroll(props, emit) {\n  var _a;\n\n  const vNodeProps = (_a = getCurrentInstance()) == null ? void 0 : _a.vnode.props;\n  const doRenderTopTrigger = (vNodeProps == null ? void 0 : vNodeProps[\"onScroll:top\"]) !== void 0;\n  const doRenderBottomTrigger = (vNodeProps == null ? void 0 : vNodeProps[\"onScroll:bottom\"]) !== void 0;\n  const scrollContainer = useElementRef();\n  const topTrigger = useElementRef();\n  const bottomTrigger = useElementRef();\n  const isObservable = computed(() => !!scrollContainer.value);\n\n  const intersectionHandler = entries => {\n    entries.forEach(entry => {\n      if (entry.isIntersecting) {\n        entry.target === topTrigger.value ? emit(\"scroll:top\") : emit(\"scroll:bottom\");\n      }\n    });\n  };\n\n  const targets = computed(() => {\n    const list = [];\n\n    if (isObservable.value) {\n      topTrigger.value && list.push(topTrigger.value);\n      bottomTrigger.value && list.push(bottomTrigger.value);\n    }\n\n    return list;\n  });\n  const options = computed(() => {\n    var _a2, _b;\n\n    return {\n      root: scrollContainer.value,\n      rootMargin: `${(_a2 = props.scrollTopMargin) != null ? _a2 : 0}px 0px ${(_b = props.scrollBottomMargin) != null ? _b : 0}px 0px`\n    };\n  });\n  useIntersectionObserver(intersectionHandler, options, targets);\n  return {\n    scrollContainer,\n    topTrigger,\n    bottomTrigger,\n    doRenderTopTrigger,\n    doRenderBottomTrigger\n  };\n}\n\nexport { useTableScrollEmits as a, useTableScroll as b, useTableScrollProps as u };","map":{"version":3,"mappings":";;;;AAIO,MAAMA,sBAAsB;EACjCC,iBAAiB;IAAEC,MAAMC,MAAR;IAAgBC,SAAS;EAAzB,CADgB;EAEjCC,oBAAoB;IAAEH,MAAMC,MAAR;IAAgBC,SAAS;EAAzB;AAFa,CAA5B;AAKM,4BAAsB,CAAC,YAAD,EAAe,eAAf,CAAtB;;AAEb,wBACEE,KADF,EAEEC,IAFF,EAGE;;;EAGM,mBAAa,kDAAsBC,KAAtB,CAA4BF,KAAzC;EACA,2BAAqB,0CAAa,cAAb,OAAiC,MAAtD;EACA,8BAAwB,0CAAa,iBAAb,OAAoC,MAA5D;EAEN,MAAMG,kBAAkBC,eAAxB;EACA,MAAMC,aAAaD,eAAnB;EACA,MAAME,gBAAgBF,eAAtB;EAEA,MAAMG,eAAeC,SAAS,MAAM,CAAC,CAACL,gBAAgBM,KAAjC,CAArB;;EAEM,4BAAuBC,OAAD,IAA0C;IAC5DA,gBAASC,KAAD,IAAW;MACzB,IAAIA,MAAMC,cAAV,EAA0B;QACxBD,MAAME,MAAN,KAAiBR,WAAWI,KAA5B,GACIR,KAAK,YAAL,CADJ,GAEIA,KAAK,eAAL,CAFJ;MAGF;IACD,CANO;EAMP,CAPG;;EAUA,gBAAUO,SAAwB,MAAM;IAC5C,MAAMM,OAAsB,EAA5B;;IAEA,IAAIP,aAAaE,KAAjB,EAAwB;MACtBJ,WAAWI,KAAX,IAAoBK,KAAKC,IAAL,CAAUV,WAAWI,KAArB,CAApB;MACAH,cAAcG,KAAd,IAAuBK,KAAKC,IAAL,CAAUT,cAAcG,KAAxB,CAAvB;IACF;;IAEO;EACR,CATe,CAAV;EAWA,gBAAUD,SAAmC,MAAO;;;IAAA;MACxDQ,MAAMb,gBAAgBM,KADkC;MAExDQ,YAAY,GAAG,aAAMtB,eAAN,kBAAyB,WAAW,YAAMI,kBAAN,iBAA4B;IAFvB;EAGxD,CAHc,CAAV;EAKkBmB,6CAAqBC,OAArB,EAA8BC,OAA9B;EAEjB;IACLjB,eADK;IAELE,UAFK;IAGLC,aAHK;IAILe,kBAJK;IAKLC;EALK;AAOT","names":["useTableScrollProps","scrollTopMargin","type","Number","default","scrollBottomMargin","props","emit","vnode","scrollContainer","useElementRef","topTrigger","bottomTrigger","isObservable","computed","value","entries","entry","isIntersecting","target","list","push","root","rootMargin","useIntersectionObserver","options","targets","doRenderTopTrigger","doRenderBottomTrigger"],"sources":["../../../../../../src/components/va-data-table/hooks/useTableScroll.ts"],"sourcesContent":["import { getCurrentInstance, computed, ExtractPropTypes } from 'vue'\n\nimport { useIntersectionObserver, useElementRef } from '../../../composables'\n\nexport const useTableScrollProps = {\n  scrollTopMargin: { type: Number, default: 0 },\n  scrollBottomMargin: { type: Number, default: 0 },\n}\n\nexport const useTableScrollEmits = ['scroll:top', 'scroll:bottom']\n\nexport default function useTableScroll (\n  props: ExtractPropTypes<typeof useTableScrollProps>,\n  emit: (event: 'scroll:bottom' | 'scroll:top', ...args: any[]) => void,\n) {\n  // NOTE: unfortunately, this is not reactive\n  // TODO: replace 'vNodeProps' with '$listeners' when it's available in vue 3\n  const vNodeProps = getCurrentInstance()?.vnode.props\n  const doRenderTopTrigger = vNodeProps?.['onScroll:top'] !== undefined\n  const doRenderBottomTrigger = vNodeProps?.['onScroll:bottom'] !== undefined\n\n  const scrollContainer = useElementRef()\n  const topTrigger = useElementRef()\n  const bottomTrigger = useElementRef()\n\n  const isObservable = computed(() => !!scrollContainer.value)\n\n  const intersectionHandler = (entries: IntersectionObserverEntry[]) => {\n    entries.forEach((entry) => {\n      if (entry.isIntersecting) {\n        entry.target === topTrigger.value\n          ? emit('scroll:top')\n          : emit('scroll:bottom')\n      }\n    })\n  }\n\n  const targets = computed<HTMLElement[]>(() => {\n    const list: HTMLElement[] = []\n\n    if (isObservable.value) {\n      topTrigger.value && list.push(topTrigger.value)\n      bottomTrigger.value && list.push(bottomTrigger.value)\n    }\n\n    return list\n  })\n\n  const options = computed<IntersectionObserverInit>(() => ({\n    root: scrollContainer.value,\n    rootMargin: `${props.scrollTopMargin ?? 0}px 0px ${props.scrollBottomMargin ?? 0}px 0px`,\n  }))\n\n  useIntersectionObserver(intersectionHandler, options, targets)\n\n  return {\n    scrollContainer,\n    topTrigger,\n    bottomTrigger,\n    doRenderTopTrigger,\n    doRenderBottomTrigger,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
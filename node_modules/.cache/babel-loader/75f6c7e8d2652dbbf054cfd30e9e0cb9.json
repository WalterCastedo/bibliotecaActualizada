{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { computed } from \"vue\";\nimport { u as useGlobalConfigSafe } from \"../services/global-config/global-config.js\";\nimport { w as warn } from \"../utils/console.js\";\nimport { u as useCache } from \"./useCache.js\";\nimport { u as useReactiveComputed } from \"./useReactiveComputed.js\";\nimport { a as getBoxShadowColor, f as getBoxShadowColorFromBg, c as getHoverColor, b as getFocusColor, g as getGradientBackground, s as shiftHSLAColor, h as setHSLAColor, d as colorToRgba, i as getStateMaskGradientBackground, n as normalizeColorName, j as cssVariableName, k as isColor, l as isCSSVariable, m as getColorLightness } from \"../services/color/utils.js\";\nconst useColorProps = {\n  color: {\n    type: String,\n    default: \"\"\n  }\n};\n\nconst useColors = () => {\n  const gc = useGlobalConfigSafe();\n\n  if (!gc) {\n    throw new Error(\"useColors must be used in setup function or Vuestic GlobalConfigPlugin is not registered!\");\n  }\n\n  const {\n    setGlobalConfig,\n    globalConfig\n  } = gc;\n  const colors = useReactiveComputed({\n    get: () => globalConfig.value.colors.variables,\n    set: v => {\n      setColors(v);\n    }\n  });\n\n  const setColors = colors2 => {\n    globalConfig.value.colors.variables = { ...globalConfig.value.colors.variables,\n      ...colors2\n    };\n  };\n\n  const getColors = () => {\n    return colors;\n  };\n\n  const getColor = (prop, defaultColor, preferVariables) => {\n    if (!defaultColor) {\n      defaultColor = getColors().primary;\n    }\n\n    const colors2 = getColors();\n\n    if (!prop) {\n      prop = getColor(defaultColor);\n    }\n\n    const colorValue = colors2[prop] || colors2[normalizeColorName(prop)];\n\n    if (colorValue) {\n      return preferVariables ? `var(${cssVariableName(prop)})` : colorValue;\n    }\n\n    if (isColor(prop)) {\n      return prop;\n    }\n\n    if (preferVariables && isCSSVariable(prop)) {\n      return prop;\n    }\n\n    return getColor(defaultColor);\n  };\n\n  const getComputedColor = color => {\n    return computed(() => getColor(color));\n  };\n\n  const colorsToCSSVariable = (colors2, prefix = \"va\") => {\n    return Object.keys(colors2).filter(key => colors2[key] !== void 0).reduce((acc, colorName) => {\n      acc[`--${prefix}-${colorName}`] = getColor(colors2[colorName], void 0, true);\n      return acc;\n    }, {});\n  };\n\n  const cache = useCache();\n\n  const getColorLightnessFromCache = color => {\n    if (typeof color !== \"string\") {\n      return getColorLightness(color);\n    }\n\n    if (!cache.colorContrast[color]) {\n      cache.colorContrast[color] = getColorLightness(color);\n    }\n\n    return cache.colorContrast[color];\n  };\n\n  const computedDarkColor = computed(() => {\n    return getColorLightnessFromCache(getColor(\"textPrimary\")) > globalConfig.value.colors.threshold ? \"textInverted\" : \"textPrimary\";\n  });\n  const computedLightColor = computed(() => {\n    return getColorLightnessFromCache(getColor(\"textPrimary\")) > globalConfig.value.colors.threshold ? \"textPrimary\" : \"textInverted\";\n  });\n\n  const getTextColor = (color, darkColor, lightColor) => {\n    darkColor = darkColor || computedDarkColor.value;\n    lightColor = lightColor || computedLightColor.value;\n    return getColorLightnessFromCache(color) > globalConfig.value.colors.threshold ? darkColor : lightColor;\n  };\n\n  const currentPresetName = computed(() => globalConfig.value.colors.currentPresetName);\n  const presets = computed(() => globalConfig.value.colors.presets);\n\n  const applyPreset = presetName => {\n    globalConfig.value.colors.currentPresetName = presetName;\n\n    if (!globalConfig.value.colors.presets[presetName]) {\n      return warn(`Preset ${presetName} does not exist`);\n    }\n\n    globalConfig.value.colors.variables = { ...globalConfig.value.colors.presets[presetName]\n    };\n  };\n\n  return {\n    colors,\n    currentPresetName,\n    presets,\n    applyPreset,\n    setColors,\n    getColors,\n    getColor,\n    getComputedColor,\n    getBoxShadowColor,\n    getBoxShadowColorFromBg,\n    getHoverColor,\n    getFocusColor,\n    getGradientBackground,\n    getTextColor,\n    shiftHSLAColor,\n    setHSLAColor,\n    colorsToCSSVariable,\n    colorToRgba,\n    getStateMaskGradientBackground\n  };\n};\n\nexport { useColorProps as a, useColors as u };","map":{"version":3,"mappings":"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","names":["useColorProps","color","type","String","default","useColors","gc","useGlobalConfigSafe","Error","setGlobalConfig","globalConfig","colors","useReactiveComputed","get","value","variables","set","v","setColors","colors2","getColors","getColor","prop","defaultColor","preferVariables","primary","colorValue","normalizeColorName","cssVariableName","isCSSVariable","computed","colorsToCSSVariable","prefix","Object","keys","filter","key","reduce","acc","colorName","cache","useCache","getColorLightness","colorContrast","threshold","getTextColor","darkColor","lightColor","computedDarkColor","computedLightColor","getColorLightnessFromCache","currentPresetName","presets","presetName","applyPreset","getComputedColor","getBoxShadowColor","getBoxShadowColorFromBg","getHoverColor","getFocusColor","getGradientBackground","shiftHSLAColor","setHSLAColor","colorToRgba","getStateMaskGradientBackground"],"sources":["../../../../src/composables/useColors.ts"],"sourcesContent":["import type { ColorInput } from 'colortranslator/dist/@types'\nimport type { ColorVariables, CssColor } from '../services/color'\nimport { computed } from 'vue'\nimport { useGlobalConfigSafe } from '../services/global-config/global-config'\nimport { warn } from '../utils/console'\nimport { useCache } from './useCache'\nimport { useReactiveComputed } from './useReactiveComputed'\nimport {\n  getBoxShadowColor,\n  getBoxShadowColorFromBg,\n  getHoverColor,\n  getFocusColor,\n  getGradientBackground,\n  isColor,\n  shiftHSLAColor,\n  setHSLAColor,\n  isCSSVariable,\n  colorToRgba,\n  getStateMaskGradientBackground,\n  getColorLightness,\n  cssVariableName,\n  normalizeColorName,\n} from '../services/color/utils'\n\n/**\n * You can add these props to any component by destructuring them inside props option.\n * @example\n * props: { ...useColorProps, componentsOwnProp, etc. }\n * It's better to add props at the beginning to make sure that component own props will be used instead in case of collision.\n */\nexport const useColorProps = {\n  color: {\n    type: String,\n    default: '',\n  },\n}\n\nexport const useColors = () => {\n  const gc = useGlobalConfigSafe()\n\n  if (!gc) {\n    throw new Error('useColors must be used in setup function or Vuestic GlobalConfigPlugin is not registered!')\n  }\n\n  const { setGlobalConfig, globalConfig } = gc\n\n  const colors = useReactiveComputed<ColorVariables>({\n    get: () => globalConfig.value.colors!.variables,\n    set: (v: ColorVariables) => { setColors(v) },\n  })\n\n  const setColors = (colors: Partial<ColorVariables>): void => {\n    globalConfig.value.colors!.variables = {\n      ...globalConfig.value.colors.variables,\n      ...colors,\n    } as ColorVariables\n  }\n\n  const getColors = (): ColorVariables => {\n    return colors\n  }\n\n  /**\n   * Returns color from config variables by name or return prop if color is a valid hex, hsl, hsla, rgb or rgba color.\n   * @param prop - should be color name or color in hex, hsl, hsla, rgb or rgba format.\n   * @param preferVariables - function should return (if possible) CSS variable instead of hex (hex is needed to set opacity).\n   * @param defaultColor - this color will be used if prop is invalid.\n   */\n  const getColor = (prop?: string, defaultColor?: string, preferVariables?: boolean): CssColor => {\n    if (!defaultColor) {\n      /**\n       * Most default color - fallback when nothing else is found.\n       */\n      defaultColor = getColors().primary\n    }\n\n    const colors = getColors()\n\n    if (!prop) {\n      prop = getColor(defaultColor)\n    }\n\n    const colorValue = colors[prop] || colors[normalizeColorName(prop)]\n    if (colorValue) {\n      return preferVariables ? `var(${cssVariableName(prop)})` : colorValue\n    }\n\n    if (isColor(prop)) {\n      return prop\n    }\n\n    if (preferVariables && isCSSVariable(prop)) {\n      return prop\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(`'${prop}' is not a proper color! Use HEX or default color themes\n      names (https://vuestic.dev/en/styles/colors#default-color-themes)`)\n    }\n\n    return getColor(defaultColor)\n  }\n\n  const getComputedColor = (color: string) => {\n    return computed(() => getColor(color))\n  }\n\n  const colorsToCSSVariable = (colors: { [colorName: string]: string | undefined }, prefix = 'va') => {\n    return Object\n      .keys(colors)\n      .filter((key) => colors[key] !== undefined)\n      .reduce((acc: Record<string, any>, colorName: string) => {\n        acc[`--${prefix}-${colorName}`] = getColor(colors[colorName], undefined, true)\n        return acc\n      }, {})\n  }\n\n  const cache = useCache()\n\n  const getColorLightnessFromCache = (color: ColorInput) => {\n    if (typeof color !== 'string') {\n      return getColorLightness(color)\n    }\n\n    if (!cache.colorContrast[color]) {\n      cache.colorContrast[color] = getColorLightness(color)\n    }\n\n    return cache.colorContrast[color]\n  }\n\n  const computedDarkColor = computed(() => {\n    return getColorLightnessFromCache(getColor('textPrimary')) > globalConfig.value.colors.threshold ? 'textInverted' : 'textPrimary'\n  })\n\n  const computedLightColor = computed(() => {\n    return getColorLightnessFromCache(getColor('textPrimary')) > globalConfig.value.colors.threshold ? 'textPrimary' : 'textInverted'\n  })\n\n  const getTextColor = (color: ColorInput, darkColor?: string, lightColor?: string) => {\n    darkColor = darkColor || computedDarkColor.value\n    lightColor = lightColor || computedLightColor.value\n    return getColorLightnessFromCache(color) > globalConfig.value.colors.threshold ? darkColor : lightColor\n  }\n\n  const currentPresetName = computed(() => globalConfig.value.colors!.currentPresetName)\n\n  const presets = computed(() => globalConfig.value.colors!.presets)\n\n  const applyPreset = (presetName: string) => {\n    globalConfig.value.colors!.currentPresetName = presetName\n    if (!globalConfig.value.colors!.presets[presetName]) {\n      return warn(`Preset ${presetName} does not exist`)\n    }\n    globalConfig.value.colors!.variables = { ...globalConfig.value.colors!.presets[presetName] }\n  }\n\n  return {\n    colors,\n    currentPresetName,\n    presets,\n    applyPreset,\n    setColors,\n    getColors,\n    getColor,\n    getComputedColor,\n    getBoxShadowColor,\n    getBoxShadowColorFromBg,\n    getHoverColor,\n    getFocusColor,\n    getGradientBackground,\n    getTextColor,\n    shiftHSLAColor,\n    setHSLAColor,\n    colorsToCSSVariable,\n    colorToRgba,\n    getStateMaskGradientBackground,\n  }\n}\n\nexport * from '../services/color/utils'\nexport * from '../services/color'\n"]},"metadata":{},"sourceType":"module"}
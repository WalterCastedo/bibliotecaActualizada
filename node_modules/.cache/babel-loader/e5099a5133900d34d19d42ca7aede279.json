{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { k as kebabCase_1, h as camelCase_1 } from \"../../../vendor.js\";\nimport { ColorTranslator } from \"colortranslator\";\n\nconst isCSSVariable = strColor => /var\\(--.+\\)/.test(strColor);\n\nconst cssVariableName = colorName => `--va-${kebabCase_1(colorName)}`;\n\nconst normalizeColorName = colorName => camelCase_1(colorName);\n\nconst colorToRgba = (color, opacity) => {\n  return new ColorTranslator(color).setA(opacity).RGBA;\n};\n\nconst getColorLightness = color => {\n  const {\n    R,\n    G,\n    B\n  } = new ColorTranslator(color);\n  return Math.sqrt(R * R * 0.241 + G * G * 0.691 + B * B * 0.068);\n};\n\nconst getBoxShadowColor = (color, opacity = 0.4) => {\n  return new ColorTranslator(color).setA(opacity).RGBA;\n};\n\nconst getBoxShadowColorFromBg = (background, opacity = 0.4) => {\n  return new ColorTranslator(background).setA(opacity).RGBA;\n};\n\nconst getHoverColor = (color, opacity = 0.2) => {\n  return new ColorTranslator(color).setA(opacity).RGBA;\n};\n\nconst getFocusColor = (color, opacity = 0.3) => {\n  return new ColorTranslator(color).setA(opacity).RGBA;\n};\n\nconst shiftHSLAColor = (color, offset) => {\n  const result = new ColorTranslator(color);\n\n  if (offset.h) {\n    result.setH(result.H + offset.h);\n  }\n\n  if (offset.s) {\n    result.setS(result.S + offset.s);\n  }\n\n  if (offset.l) {\n    result.setL(result.L + offset.l);\n  }\n\n  if (offset.a) {\n    result.setA(result.A + offset.a);\n  }\n\n  return result.HSLA;\n};\n\nconst setHSLAColor = (color, newColor) => {\n  const result = new ColorTranslator(color);\n\n  if (newColor.h !== void 0) {\n    result.setH(newColor.h);\n  }\n\n  if (newColor.s !== void 0) {\n    result.setS(newColor.s);\n  }\n\n  if (newColor.l !== void 0) {\n    result.setL(newColor.l);\n  }\n\n  if (newColor.a !== void 0) {\n    result.setA(newColor.a);\n  }\n\n  return result.HSLA;\n};\n\nconst shiftGradientColor = color => {\n  const newColor = ColorTranslator.toHSLA(color, false);\n\n  if (newColor.s < 10) {\n    return shiftHSLAColor(newColor, {\n      h: 2,\n      s: 5,\n      l: 10\n    });\n  }\n\n  if (newColor.s < 30) {\n    return shiftHSLAColor(newColor, {\n      s: -14,\n      l: 11\n    });\n  }\n\n  if (newColor.h >= 0 && newColor.h < 44 || newColor.h >= 285) {\n    return shiftHSLAColor(newColor, {\n      h: 11,\n      s: 27,\n      l: 8\n    });\n  }\n\n  if (newColor.h >= 44 && newColor.h < 85) {\n    return shiftHSLAColor(newColor, {\n      h: 3,\n      l: 9\n    });\n  }\n\n  if (newColor.h >= 85 && newColor.h < 165) {\n    return shiftHSLAColor(newColor, {\n      h: 16,\n      l: 14\n    });\n  }\n\n  if (newColor.h >= 165 && newColor.h < 285) {\n    return shiftHSLAColor(newColor, {\n      h: -15,\n      s: 3,\n      l: 2\n    });\n  }\n\n  throw new Error(\"This method should handle all colors. But it didn't for some reason.\");\n};\n\nconst getGradientBackground = color => {\n  const colorLeft = shiftGradientColor(color);\n  const colorRight = ColorTranslator.toHSLA(color);\n  return `linear-gradient(to right, ${colorLeft}, ${colorRight})`;\n};\n\nconst getStateMaskGradientBackground = (color, maskColor, maskOpacity) => {\n  const mask = colorToRgba(maskColor, maskOpacity);\n  return `linear-gradient(0deg, ${mask}, ${mask}), ${color}`;\n};\n\nconst isColor = strColor => {\n  const cssColorRegex = /^#([\\da-f]{3}){1,2}$|^#([\\da-f]{4}){1,2}$|(rgb|hsl)a?\\((\\s*-?\\d+%?\\s*,){2}(\\s*-?\\d+%?\\s*,?\\s*\\)?)(,\\s*(0?\\.\\d+)?|1)?\\)/;\n  return cssColorRegex.test(strColor.toLocaleLowerCase());\n};\n\nconst applyColors = (color1, color2) => {\n  const c1 = new ColorTranslator(color1);\n  const c2 = new ColorTranslator(color2);\n  const weight = c2.A;\n\n  if (weight === 1) {\n    return c2.RGBA;\n  }\n\n  if (weight === 0) {\n    return c1.RGBA;\n  }\n\n  c1.setR(Math.round(c1.R * (1 - weight) + c2.R * weight));\n  c1.setG(Math.round(c1.G * (1 - weight) + c2.G * weight));\n  c1.setB(Math.round(c1.B * (1 - weight) + c2.B * weight));\n  return c1.RGBA;\n};\n\nexport { getBoxShadowColor as a, getFocusColor as b, getHoverColor as c, colorToRgba as d, applyColors as e, getBoxShadowColorFromBg as f, getGradientBackground as g, setHSLAColor as h, getStateMaskGradientBackground as i, cssVariableName as j, isColor as k, isCSSVariable as l, getColorLightness as m, normalizeColorName as n, shiftHSLAColor as s };","map":{"version":3,"mappings":"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","names":["isCSSVariable","strColor","test","cssVariableName","colorName","kebabCase","normalizeColorName","camelCase","color","opacity","ColorTranslator","setA","RGBA","R","G","B","sqrt","getBoxShadowColor","getBoxShadowColorFromBg","background","getHoverColor","getFocusColor","offset","h","result","setH","H","s","setS","S","l","setL","L","a","A","HSLA","newColor","toHSLA","shiftHSLAColor","Error","shiftGradientColor","colorLeft","colorRight","getStateMaskGradientBackground","maskColor","maskOpacity","colorToRgba","mask","cssColorRegex","toLocaleLowerCase","color1","color2","weight","c2","c1","Math","round"],"sources":["../../../../../src/services/color/utils.ts"],"sourcesContent":["import kebabCase from 'lodash/kebabCase.js'\nimport camelCase from 'lodash/camelCase.js'\nimport { ColorTranslator } from 'colortranslator'\nimport type { HSLObject, ColorInput } from 'colortranslator/dist/@types'\n\nexport const isCSSVariable = (strColor: string): boolean => /var\\(--.+\\)/.test(strColor)\nexport const cssVariableName = (colorName: string) => `--va-${kebabCase(colorName)}`\nexport const normalizeColorName = (colorName: string) => camelCase(colorName)\n\nexport const colorToRgba = (color: ColorInput, opacity: number) => {\n  return new ColorTranslator(color).setA(opacity).RGBA\n}\n\nexport const getColorLightness = (color: ColorInput) => {\n  const { R, G, B } = new ColorTranslator(color)\n  return Math.sqrt(R * R * 0.241 + G * G * 0.691 + B * B * 0.068)\n}\n\nexport const getBoxShadowColor = (color: ColorInput, opacity = 0.4) => {\n  return new ColorTranslator(color).setA(opacity).RGBA\n}\n\nexport const getBoxShadowColorFromBg = (background: ColorInput, opacity = 0.4) => {\n  return new ColorTranslator(background).setA(opacity).RGBA\n}\n\nexport const getHoverColor = (color: ColorInput, opacity = 0.2) => {\n  return new ColorTranslator(color).setA(opacity).RGBA\n}\n\nexport const getFocusColor = (color: ColorInput, opacity = 0.3) => {\n  return new ColorTranslator(color).setA(opacity).RGBA\n}\n\nexport const shiftHSLAColor = (color: ColorInput, offset: { h?: number; s?: number; l?: number; a?: number }) => {\n  const result = new ColorTranslator(color)\n\n  if (offset.h) { result.setH(result.H + offset.h) }\n\n  if (offset.s) { result.setS(result.S + offset.s) }\n\n  if (offset.l) { result.setL(result.L + offset.l) }\n\n  if (offset.a) { result.setA(result.A + offset.a) }\n\n  return result.HSLA\n}\n\nexport const setHSLAColor = (color: ColorInput, newColor: { h?: number; s?: number; l?: number; a?: number }) => {\n  const result = new ColorTranslator(color)\n\n  if (newColor.h !== undefined) { result.setH(newColor.h) }\n\n  if (newColor.s !== undefined) { result.setS(newColor.s) }\n\n  if (newColor.l !== undefined) { result.setL(newColor.l) }\n\n  if (newColor.a !== undefined) { result.setA(newColor.a) }\n\n  return result.HSLA\n}\n\n/**\n * This method guesses second color for gradient based on first one.\n * Calculation method should differ for different colors, so we split color circle\n * in zones.\n *\n * @param color\n */\nexport const shiftGradientColor = (color: ColorInput): string => {\n  const newColor = ColorTranslator.toHSLA(color, false) as HSLObject\n\n  // Gray\n  if (newColor.s < 10) {\n    return shiftHSLAColor(newColor, { h: 2, s: 5, l: 10 })\n  }\n  // Unsaturated (too pale, gray-ish, monotone)\n  // For unsaturated color, hue change does nothing.\n  if (newColor.s < 30) {\n    return shiftHSLAColor(newColor, { s: -14, l: 11 })\n  }\n  // Red\n  if ((newColor.h >= 0 && newColor.h < 44) || (newColor.h >= 285)) {\n    return shiftHSLAColor(newColor, { h: 11, s: 27, l: 8 })\n  }\n  // Yellow\n  if (newColor.h >= 44 && newColor.h < 85) {\n    return shiftHSLAColor(newColor, { h: 3, l: 9 })\n  }\n  // Green\n  if (newColor.h >= 85 && newColor.h < 165) {\n    return shiftHSLAColor(newColor, { h: 16, l: 14 })\n  }\n  // Blue\n  if (newColor.h >= 165 && newColor.h < 285) {\n    return shiftHSLAColor(newColor, { h: -15, s: 3, l: 2 })\n  }\n\n  throw new Error('This method should handle all colors. But it didn\\'t for some reason.')\n}\n\nexport const getGradientBackground = (color: string) => {\n  const colorLeft = shiftGradientColor(color)\n  const colorRight = ColorTranslator.toHSLA(color)\n\n  return `linear-gradient(to right, ${colorLeft}, ${colorRight})`\n}\n\nexport const getStateMaskGradientBackground = (color: string, maskColor: string, maskOpacity: number) => {\n  const mask = colorToRgba(maskColor, maskOpacity)\n\n  return `linear-gradient(0deg, ${mask}, ${mask}), ${color}`\n}\n\n/**\n * Check if color is valid hsl, hsla, rga, rgba or hex color\n * Taken from https://www.regextester.com/103656\n * Check options <or> isCSSVariable(prop) <or> CSS.supports('color', prop) deleted due to problems with SSR and opacity\n * Details are in the discussion: https://github.com/epicmaxco/vuestic-ui/pull/1589\n * @param strColor\n */\nexport const isColor = (strColor: string): boolean => {\n  // Need to use Regex instead of DOM methods because we support SSR\n  const cssColorRegex = /^#([\\da-f]{3}){1,2}$|^#([\\da-f]{4}){1,2}$|(rgb|hsl)a?\\((\\s*-?\\d+%?\\s*,){2}(\\s*-?\\d+%?\\s*,?\\s*\\)?)(,\\s*(0?\\.\\d+)?|1)?\\)/\n\n  return cssColorRegex.test(strColor.toLocaleLowerCase())\n}\n\nexport const applyColors = (color1: ColorInput, color2: ColorInput) => {\n  const c1 = new ColorTranslator(color1)\n  const c2 = new ColorTranslator(color2)\n  const weight = c2.A\n\n  if (weight === 1) { return c2.RGBA }\n  if (weight === 0) { return c1.RGBA }\n\n  c1.setR(Math.round((c1.R) * (1 - weight) + (c2.R) * weight))\n  c1.setG(Math.round((c1.G) * (1 - weight) + (c2.G) * weight))\n  c1.setB(Math.round((c1.B) * (1 - weight) + (c2.B) * weight))\n\n  return c1.RGBA\n}\n"]},"metadata":{},"sourceType":"module"}
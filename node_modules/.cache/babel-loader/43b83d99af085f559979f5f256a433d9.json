{"ast":null,"code":"import { watch, inject, computed, onMounted, onBeforeUnmount } from \"vue\";\nimport { g as flatten_1, e as isString_1, f as isFunction_1 } from \"../../vendor.js\";\nimport { u as useSyncProp } from \"./useSyncProp.js\";\nimport { u as useFocus } from \"./useFocus.js\";\nimport { F as FormServiceKey } from \"../components/va-form/consts.js\";\n\nconst normalizeValidationRules = (rules = [], callArguments = null) => {\n  if (isString_1(rules)) {\n    rules = [rules];\n  }\n\n  return rules.map(rule => isFunction_1(rule) ? rule(callArguments) : rule);\n};\n\nconst useValidationProps = {\n  modelValue: {\n    required: false\n  },\n  error: {\n    type: Boolean,\n    default: void 0\n  },\n  errorMessages: {\n    type: [Array, String],\n    default: void 0\n  },\n  errorCount: {\n    type: [String, Number],\n    default: 1\n  },\n  rules: {\n    type: Array,\n    default: () => []\n  },\n  success: {\n    type: Boolean,\n    default: false\n  },\n  messages: {\n    type: [Array, String],\n    default: () => []\n  },\n  immediateValidation: {\n    type: Boolean,\n    default: false\n  }\n};\nconst useValidationEmits = [\"update:error\", \"update:errorMessages\"];\n\nconst useValidation = (props, emit, options) => {\n  const {\n    reset,\n    focus\n  } = options;\n  const {\n    isFocused,\n    onFocus,\n    onBlur\n  } = useFocus();\n  let canValidate = true;\n  const [computedError] = useSyncProp(\"error\", props, emit, false);\n  const [computedErrorMessages] = useSyncProp(\"errorMessages\", props, emit, []);\n\n  const resetValidation = () => {\n    computedError.value = false;\n    computedErrorMessages.value = [];\n  };\n\n  const withoutValidation = cb => {\n    canValidate = false;\n    cb();\n  };\n\n  const validate = () => {\n    if (!props.rules || !props.rules.length || !canValidate) {\n      canValidate = true;\n      return true;\n    }\n\n    let error = false;\n    let errorMessages = [];\n    const rules = flatten_1(props.rules);\n    normalizeValidationRules(rules, props.modelValue).forEach(validationResult => {\n      if (isString_1(validationResult)) {\n        errorMessages = [...errorMessages, validationResult];\n        error = true;\n      } else if (validationResult === false) {\n        error = true;\n      }\n    });\n    computedErrorMessages.value = errorMessages;\n    computedError.value = error;\n    return !error;\n  };\n\n  watch(isFocused, newVal => !newVal && validate());\n  watch(() => props.modelValue, () => validate(), {\n    immediate: props.immediateValidation\n  });\n  const context = {\n    resetValidation,\n    focus,\n    validate,\n    reset,\n    hasError: () => computedError.value\n  };\n  const form = inject(FormServiceKey, void 0);\n  const validationAriaAttributes = computed(() => ({\n    \"aria-invalid\": !!computedErrorMessages.value.length,\n    \"aria-errormessage\": typeof computedErrorMessages.value === \"string\" ? computedErrorMessages.value : computedErrorMessages.value.join(\", \")\n  }));\n  onMounted(() => {\n    form == null ? void 0 : form.onChildMounted(context);\n  });\n  onBeforeUnmount(() => {\n    form == null ? void 0 : form.onChildUnmounted(context);\n  });\n  return {\n    computedError,\n    computedErrorMessages,\n    listeners: {\n      onFocus,\n      onBlur\n    },\n    validate,\n    resetValidation,\n    withoutValidation,\n    validationAriaAttributes\n  };\n};\n\nexport { useValidationEmits as a, useValidation as b, useValidationProps as u };","map":{"version":3,"mappings":"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","names":["normalizeValidationRules","rules","callArguments","isString","map","rule","isFunction","useValidationProps","modelValue","required","error","type","Boolean","default","errorMessages","Array","String","errorCount","Number","success","messages","immediateValidation","useValidation","props","emit","options","reset","focus","isFocused","onFocus","onBlur","useFocus","canValidate","computedError","useSyncProp","computedErrorMessages","resetValidation","value","cb","validate","length","flatten","forEach","validationResult","watch","newVal","immediate","context","hasError","inject","FormServiceKey","computed","join","onMounted","form","onChildMounted","onBeforeUnmount","onChildUnmounted","listeners","withoutValidation","validationAriaAttributes"],"sources":["../../../../src/composables/useValidation.ts"],"sourcesContent":["import {\n  watch,\n  inject,\n  computed,\n  onMounted,\n  onBeforeUnmount,\n  PropType,\n  ExtractPropTypes,\n} from 'vue'\nimport flatten from 'lodash/flatten.js'\nimport isFunction from 'lodash/isFunction.js'\nimport isString from 'lodash/isString.js'\n\nimport { useSyncProp } from './useSyncProp'\nimport { useFocus } from './useFocus'\nimport { FormServiceKey } from '../components/va-form/consts'\n\ntype ValidationRule<V extends any = any> = ((v: V) => any | string)\n\ntype UseValidationOptions = {\n  reset: () => void\n  focus: () => void\n}\n\nconst normalizeValidationRules = (rules: string | ValidationRule[] = [], callArguments: unknown = null) => {\n  if (isString(rules)) { rules = [rules] as any }\n\n  return (rules as ValidationRule[])\n    .map((rule) => isFunction(rule) ? rule(callArguments) : rule)\n}\n\nexport const useValidationProps = {\n  modelValue: { required: false },\n  error: { type: Boolean, default: undefined },\n  errorMessages: { type: [Array, String] as PropType<string[] | string>, default: undefined },\n  errorCount: { type: [String, Number], default: 1 },\n  rules: { type: Array as PropType<ValidationRule<any>[]>, default: () => [] as any },\n  success: { type: Boolean, default: false },\n  messages: { type: [Array, String] as PropType<string[] | string>, default: () => [] },\n  immediateValidation: { type: Boolean, default: false },\n}\n\nexport type ValidationProps<V extends any> = typeof useValidationProps & {\n  modelValue: { type: PropType<V> }\n  rules: { type: PropType<ValidationRule<V>[]> }\n}\n\nexport const useValidationEmits = ['update:error', 'update:errorMessages']\n\nexport const useValidation = <V, P extends ExtractPropTypes<typeof useValidationProps>>(\n  props: P,\n  emit: (event: any, ...args: any[]) => void,\n  options: UseValidationOptions,\n) => {\n  const { reset, focus } = options\n  const { isFocused, onFocus, onBlur } = useFocus()\n  let canValidate = true\n\n  const [computedError] = useSyncProp('error', props, emit, false)\n  const [computedErrorMessages] = useSyncProp('errorMessages', props, emit, [] as string[])\n\n  const resetValidation = () => {\n    computedError.value = false\n    computedErrorMessages.value = []\n  }\n\n  const withoutValidation = (cb: () => any): void => {\n    canValidate = false\n    cb()\n  }\n\n  const validate = (): boolean => {\n    if (!props.rules || !props.rules.length || !canValidate) {\n      canValidate = true\n\n      return true\n    }\n\n    let error = false\n    let errorMessages: string[] = []\n\n    const rules = flatten(props.rules)\n\n    normalizeValidationRules(rules, props.modelValue)\n      .forEach((validationResult: boolean | string) => {\n        if (isString(validationResult)) {\n          errorMessages = [...errorMessages, validationResult]\n          error = true\n        } else if (validationResult === false) {\n          error = true\n        }\n      })\n\n    computedErrorMessages.value = errorMessages\n    computedError.value = error\n\n    return !error\n  }\n\n  watch(isFocused, (newVal) => !newVal && validate())\n\n  watch(() => props.modelValue, () => validate(), { immediate: props.immediateValidation })\n\n  const context = {\n    resetValidation,\n    focus,\n    validate,\n    reset,\n    hasError: () => computedError.value,\n  }\n\n  const form = inject(FormServiceKey, undefined)\n\n  const validationAriaAttributes = computed(() => ({\n    'aria-invalid': !!computedErrorMessages.value.length,\n    'aria-errormessage': typeof computedErrorMessages.value === 'string'\n      ? computedErrorMessages.value\n      : computedErrorMessages.value.join(', '),\n  }))\n\n  onMounted(() => {\n    form?.onChildMounted(context as any)\n  })\n\n  onBeforeUnmount(() => {\n    form?.onChildUnmounted(context as any)\n  })\n\n  return {\n    computedError,\n    computedErrorMessages,\n    listeners: { onFocus, onBlur },\n    validate,\n    resetValidation,\n    withoutValidation,\n    validationAriaAttributes,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
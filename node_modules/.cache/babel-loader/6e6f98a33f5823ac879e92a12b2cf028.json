{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { onMounted, onBeforeUnmount, ref, computed, watch } from \"vue\";\n\nconst useCarouselAnimation = (props, currentSlide) => {\n  let animationInterval = -1;\n  let direction = 1;\n\n  const start = () => {\n    if (!props.autoscroll) {\n      return;\n    }\n\n    clearInterval(animationInterval);\n    animationInterval = setInterval(() => {\n      if (props.infinite) {\n        currentSlide.value += 1;\n\n        if (currentSlide.value >= props.items.length) {\n          currentSlide.value = 0;\n        }\n      } else {\n        if (currentSlide.value <= 0) {\n          direction = 1;\n        }\n\n        if (currentSlide.value >= props.items.length - 1) {\n          direction = -1;\n        }\n\n        currentSlide.value += direction;\n      }\n    }, props.autoscrollInterval);\n  };\n\n  let pauseTimeout;\n\n  const pause = () => {\n    if (!props.autoscroll) {\n      return;\n    }\n\n    clearInterval(animationInterval);\n    pauseTimeout = setTimeout(() => {\n      start();\n      clearTimeout(pauseTimeout);\n    }, props.autoscrollPauseDuration);\n  };\n\n  const stop = () => {\n    clearInterval(animationInterval);\n    clearTimeout(pauseTimeout);\n  };\n\n  onMounted(() => start());\n  onBeforeUnmount(() => stop());\n\n  const withPause = fn => {\n    return (...args) => {\n      pause();\n      fn(...args);\n    };\n  };\n\n  const slidesContainerStyle = ref({\n    transition: void 0\n  });\n  const sliderToBeShown = ref(0);\n  const computedSlidesStyle = computed(() => {\n    if (props.effect === \"fade\") {\n      return { ...slidesContainerStyle.value,\n        transition: \"none\"\n      };\n    }\n\n    if (props.vertical) {\n      return { ...slidesContainerStyle.value,\n        transform: `translateY(${sliderToBeShown.value * -100}%)`\n      };\n    }\n\n    return { ...slidesContainerStyle.value,\n      transform: `translateX(${sliderToBeShown.value * -100}%)`\n    };\n  });\n  const animator = {\n    isAnimating: false,\n    speed: 0.3,\n    order: [],\n\n    move(from, to) {\n      const last = props.items.length - 1;\n      const firstAfterLast = props.items.length;\n\n      if (to === 0 && from === last) {\n        this.order.push({\n          to: firstAfterLast\n        });\n        this.order.push({\n          to: 0,\n          animate: false\n        });\n      } else if (to === last && from === 0) {\n        this.order.push({\n          to: firstAfterLast,\n          animate: false\n        });\n        this.order.push({\n          to\n        });\n      } else {\n        this.order.push({\n          to\n        });\n      }\n\n      if (!this.isAnimating) {\n        this.runAnimation();\n      }\n    },\n\n    runAnimation() {\n      this.isAnimating = true;\n      const animation = this.order.shift();\n\n      if (!animation) {\n        this.isAnimating = false;\n        return;\n      }\n\n      sliderToBeShown.value = animation == null ? void 0 : animation.to;\n\n      if (animation.animate || animation.animate === void 0) {\n        slidesContainerStyle.value.transition = `all ${this.speed}s linear`;\n        setTimeout(() => {\n          this.runAnimation();\n        }, this.speed * 1e3);\n      } else {\n        slidesContainerStyle.value.transition = \"none\";\n        setTimeout(() => {\n          this.runAnimation();\n        }, 16);\n      }\n    }\n\n  };\n  watch(currentSlide, (newValue, oldValue) => {\n    animator.move(oldValue, newValue);\n  });\n  const slides = computed(() => {\n    if (props.effect === \"fade\") {\n      return [props.items[currentSlide.value]];\n    }\n\n    if (props.infinite) {\n      return [...props.items, props.items[0]];\n    }\n\n    return props.items;\n  });\n  return {\n    start,\n    pause,\n    stop,\n    withPause,\n    computedSlidesStyle,\n    slides\n  };\n};\n\nexport { useCarouselAnimation as u };","map":{"version":3,"mappings":"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","names":["props","currentSlide","animationInterval","direction","start","autoscroll","clearInterval","setInterval","infinite","value","items","length","autoscrollInterval","pause","pauseTimeout","setTimeout","clearTimeout","autoscrollPauseDuration","stop","onMounted","onBeforeUnmount","fn","args","slidesContainerStyle","ref","transition","computed","effect","vertical","transform","sliderToBeShown","animator","isAnimating","speed","order","move","from","to","last","push","firstAfterLast","animate","runAnimation","shift","animation","watch","newValue","oldValue","withPause","computedSlidesStyle","slides"],"sources":["../../../../../../src/components/va-carousel/hooks/useCarouselAnimation.ts"],"sourcesContent":["import { computed, onBeforeUnmount, onMounted, ref, Ref, watch } from 'vue'\n\nexport const useCarouselAnimation = (props: {\n  items: any[],\n  autoscrollInterval: number,\n  autoscrollPauseDuration: number,\n  autoscroll: boolean,\n  infinite: boolean,\n  effect: 'fade' | 'transition',\n  vertical: boolean,\n  fadeKeyframe: string,\n}, currentSlide: Ref<number>) => {\n  let animationInterval = -1\n  let direction = 1\n\n  const start = () => {\n    if (!props.autoscroll) { return }\n\n    clearInterval(animationInterval)\n    animationInterval = setInterval(() => {\n      if (props.infinite) {\n        currentSlide.value += 1\n        if (currentSlide.value >= props.items.length) { currentSlide.value = 0 }\n      } else {\n        if (currentSlide.value <= 0) { direction = 1 }\n        if (currentSlide.value >= props.items.length - 1) { direction = -1 }\n        currentSlide.value += direction\n      }\n    }, props.autoscrollInterval) as any\n  }\n\n  let pauseTimeout: number\n  const pause = () => {\n    if (!props.autoscroll) { return }\n\n    clearInterval(animationInterval)\n\n    pauseTimeout = setTimeout(() => {\n      start()\n      clearTimeout(pauseTimeout)\n    }, props.autoscrollPauseDuration) as any\n  }\n\n  const stop = () => {\n    clearInterval(animationInterval)\n    clearTimeout(pauseTimeout)\n  }\n\n  onMounted(() => start())\n  onBeforeUnmount(() => stop())\n\n  const withPause = <T extends (...args: any[]) => any>(fn: T) => {\n    return (...args: Parameters<T>) => { pause(); fn(...args) }\n  }\n\n  const slidesContainerStyle = ref<Record<string, any>>({\n    transition: undefined as string | undefined,\n  })\n\n  /**\n   * Used for infinite loop. In infinite loop additional first item is placed after all items.\n   * Use own currentSlider, which will not update model value if we need to show slide that placed after all items\n   */\n  const sliderToBeShown = ref(0)\n\n  const computedSlidesStyle = computed(() => {\n    if (props.effect === 'fade') {\n      return {\n        ...slidesContainerStyle.value,\n        transition: 'none',\n      }\n    }\n\n    if (props.vertical) {\n      return {\n        ...slidesContainerStyle.value,\n        transform: `translateY(${sliderToBeShown.value * -100}%)`,\n      }\n    }\n\n    return {\n      ...slidesContainerStyle.value,\n      transform: `translateX(${sliderToBeShown.value * -100}%)`,\n    }\n  })\n\n  const animator = {\n    isAnimating: false,\n\n    speed: 0.3,\n\n    order: [] as { to: number, animate?: boolean }[],\n\n    move (from: number, to: number) {\n      const last = props.items.length - 1\n      const firstAfterLast = props.items.length\n\n      if (to === 0 && from === last) {\n        this.order.push({ to: firstAfterLast })\n        this.order.push({ to: 0, animate: false })\n      } else if (to === last && from === 0) {\n        this.order.push({ to: firstAfterLast, animate: false })\n        this.order.push({ to })\n      } else {\n        this.order.push({ to })\n      }\n\n      if (!this.isAnimating) { this.runAnimation() }\n    },\n\n    runAnimation () {\n      this.isAnimating = true\n\n      const animation = this.order.shift()\n\n      if (!animation) { this.isAnimating = false; return }\n\n      sliderToBeShown.value = animation?.to\n\n      if (animation.animate || animation.animate === undefined) {\n        slidesContainerStyle.value.transition = `all ${this.speed}s linear`\n        setTimeout(() => { this.runAnimation() }, this.speed * 1000)\n      } else {\n        slidesContainerStyle.value.transition = 'none'\n        setTimeout(() => { this.runAnimation() }, 16)\n      }\n    },\n  }\n\n  watch(currentSlide, (newValue, oldValue) => {\n    animator.move(oldValue, newValue)\n  })\n\n  /** Animation should control how much slides to display */\n  const slides = computed(() => {\n    if (props.effect === 'fade') {\n      return [props.items[currentSlide.value]]\n    }\n\n    if (props.infinite) {\n      return [...props.items, props.items[0]]\n    }\n\n    return props.items\n  })\n\n  return {\n    start,\n    pause,\n    stop,\n    withPause,\n    computedSlidesStyle,\n    slides,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { getCurrentInstance, shallowReadonly } from \"vue\";\nimport { u as useComponentConfigProps } from \"../component-config/utils/use-component-config-props.js\";\n\nconst toCamelCase = str => str.replace(/-([a-z])/g, g => g[1].toUpperCase());\n\nconst findCamelCased = (obj, key) => {\n  const found = Object.keys(obj).find(k => toCamelCase(k) === key);\n  return found && obj[found];\n};\n\nconst createPropsWithCustomConfig = (instance, propsFromConfig) => {\n  const instanceProps = instance.props;\n  return new Proxy(instanceProps, {\n    get: (target, key) => {\n      var _a;\n\n      if (typeof key !== \"string\") {\n        return target[key];\n      }\n\n      const incomingProps = instance.vnode.props || {};\n      const originalProp = target[key];\n      const propFromConfig = (_a = propsFromConfig.value) == null ? void 0 : _a[key];\n      const incomingProp = findCamelCased(incomingProps, key);\n\n      if (incomingProp !== void 0) {\n        return originalProp;\n      }\n\n      if (propFromConfig !== void 0) {\n        return propFromConfig;\n      }\n\n      return originalProp;\n    }\n  });\n};\n\nconst patchInstanceProps = (instance, props) => {\n  instance.props = props;\n};\n\nconst createProxyComponent = component => {\n  const customSetup = (originalProps, ctx) => {\n    var _a;\n\n    const instance = getCurrentInstance();\n    const propsFromConfig = useComponentConfigProps(component, originalProps);\n    const props = createPropsWithCustomConfig(instance, propsFromConfig);\n    patchInstanceProps(instance, props);\n    return (_a = component.setup) == null ? void 0 : _a.call(component, shallowReadonly(props), ctx);\n  };\n\n  return new Proxy(component, {\n    get(target, key) {\n      if (key === \"setup\") {\n        return customSetup;\n      }\n\n      return target[key];\n    }\n\n  });\n};\n\nexport { createProxyComponent as c };","map":{"version":3,"mappings":";;;AAQA,MAAMA,cAAeC,GAAD,IAAiBA,IAAIC,OAAJ,CAAY,WAAZ,EAA0BC,CAAD,IAAOA,EAAE,CAAF,EAAKC,WAAL,EAAhC,CAArC;;AAEA,MAAMC,iBAAiB,CAACC,GAAD,EAA+BC,GAA/B,KAA+C;EAC9D,cAAQC,OAAOC,IAAP,CAAYH,GAAZ,EAAiBI,IAAjB,CAAuBC,CAAD,IAAOX,YAAYW,CAAZ,MAAmBJ,GAAhD,CAAR;EACN,OAAOK,SAASN,IAAIM,KAAJ,CAAhB;AACF,CAHA;;AASA,MAAMC,8BAA8B,CAACC,QAAD,EAAsCC,eAAtC,KAAsE;EAKxG,MAAMC,gBAAuBF,SAASG,KAAtC;EAEO,WAAIC,KAAJ,CAAUF,aAAV,EAAyB;IAC9BG,KAAK,CAACC,MAAD,EAASb,GAAT,KAAyB;;;MACxB,WAAOA,GAAP,KAAe,QAAf,EAAyB;QAAE,OAAOa,OAAOb,GAAP,CAAP;MAAmB;;MAMlD,MAAMc,gBAA0BP,SAASQ,KAAT,CAAeL,KAAf,IAAwB,EAAxD;MAQA,MAAMM,eAAeH,OAAOb,GAAP,CAArB;MACM,uBAAiB,sBAAgBiB,KAAhB,wBAAwBjB,GAAxB,CAAjB;MACA,qBAAeF,eAAegB,aAAf,EAA8Bd,GAA9B,CAAf;;MAEN,IAAIkB,iBAAiB,MAArB,EAAgC;QACvB;MACT;;MAGA,IAAIC,mBAAmB,MAAvB,EAAkC;QACzB;MACT;;MAEO;IACT;EA9B8B,CAAzB;AAgCT,CAvCA;;AA6CA,MAAMC,qBAAqB,CAACb,QAAD,EAAsCG,KAAtC,KAAuD;EAChFH,SAASG,KAAT,GAAiBA,KAAjB;AACF,CAFA;;AAIa,6BAAmDW,SAA5B,IAA6C;EACzE,oBAAc,CAACC,aAAD,EAAuBC,GAAvB,KAA6C;;;IAC/D,MAAMhB,WAAWiB,oBAAjB;IACM,wBAAkBC,wBAAwBJ,SAAxB,EAAmCC,aAAnC,CAAlB;IAEA,cAAQhB,4BAA4BC,QAA5B,EAAsCC,eAAtC,CAAR;IAENY,mBAAmBb,QAAnB,EAA6BG,KAA7B;IAEA,OAAO,gBAAUgB,KAAV,wCAAkBC,gBAAgBjB,KAAhB,CAAlB,EAA0Ca,GAA1C,CAAP;EAAoD,CARhD;;EAWC,WAAIZ,KAAJ,CAAUU,SAAV,EAAqB;IAC1BT,IAAKC,MAAL,EAAab,GAAb,EAAuB;MACrB,IAAIA,QAAQ,OAAZ,EAAqB;QAAS;MAAY;;MAE1C,OAAOa,OAAOb,GAAP,CAAP;IACF;;EAL0B,CAArB;AAOT,CAnBa","names":["toCamelCase","str","replace","g","toUpperCase","findCamelCased","obj","key","Object","keys","find","k","found","createPropsWithCustomConfig","instance","propsFromConfig","instanceProps","props","Proxy","get","target","incomingProps","vnode","originalProp","value","incomingProp","propFromConfig","patchInstanceProps","component","originalProps","ctx","getCurrentInstance","useComponentConfigProps","setup","shallowReadonly"],"sources":["../../../../../src/services/config-transport/createProxyComponent.ts"],"sourcesContent":["import { getCurrentInstance, ComponentInternalInstance, DefineComponent, SetupContext, Ref, shallowReadonly } from 'vue'\nimport { useComponentConfigProps } from '../component-config/utils/use-component-config-props'\n\n/** Compiled and reactive props. By default they passed to setup fn */\ntype Props = Record<string, unknown>;\n/** Raw props */\ntype RawProps = Record<string, unknown>;\n\nconst toCamelCase = (str: string) => str.replace(/-([a-z])/g, (g) => g[1].toUpperCase())\n\nconst findCamelCased = (obj: Record<string, unknown>, key: string) => {\n  const found = Object.keys(obj).find((k) => toCamelCase(k) === key)\n  return found && obj[found]\n}\n\n/**\n * @param propsFromConfig Ref of custom props. Required to be ref so vue can rerender component on custom props change.\n * @returns new props object, where some props replaced with props from config.\n */\nconst createPropsWithCustomConfig = (instance: ComponentInternalInstance, propsFromConfig: Ref<Props>) => {\n  /**\n   * Reactive and compiled props. Compiled props considering default value, Boolean transformation etc.\n   * It is a default props that passed to setup function.\n   */\n  const instanceProps: Props = instance.props\n\n  return new Proxy(instanceProps, {\n    get: (target, key: string) => {\n      if (typeof key !== 'string') { return target[key] }\n\n      /**\n       * Props passed to VNode. Not compiled at all and not reactive.\n       * VNode props contained only props passed from parent.\n       */\n      const incomingProps: RawProps = instance.vnode.props || {}\n\n      /**\n       * Make sure to access both original and from config prop in get.\n       * Since instanceProps and propsFromConfig both are reactive, we need to know that both of\n       * this objects are dependency of effect where proxy is used.\n       * If original prop will not be accessed vue will not track reactivity for original props object.\n       */\n      const originalProp = target[key]\n      const propFromConfig = propsFromConfig.value?.[key]\n      const incomingProp = findCamelCased(incomingProps, key)\n\n      if (incomingProp !== undefined) {\n        return originalProp\n      }\n\n      // Return prop from config only if user didn't pass props manually\n      if (propFromConfig !== undefined) {\n        return propFromConfig\n      }\n\n      return originalProp\n    },\n  })\n}\n\n/**\n * Patch instance props with Proxy.\n * This will change props object during render and in Devtools.\n */\nconst patchInstanceProps = (instance: ComponentInternalInstance, props: Props) => {\n  instance.props = props\n}\n\nexport const createProxyComponent = <T extends DefineComponent>(component: T) => {\n  const customSetup = (originalProps: Props, ctx: SetupContext) => {\n    const instance = getCurrentInstance()! // Not null during setup call\n    const propsFromConfig = useComponentConfigProps(component, originalProps)\n\n    const props = createPropsWithCustomConfig(instance, propsFromConfig)\n\n    patchInstanceProps(instance, props)\n\n    return component.setup?.(shallowReadonly(props), ctx)\n  }\n\n  return new Proxy(component, {\n    get (target, key: any) {\n      if (key === 'setup') { return customSetup }\n\n      return target[key]\n    },\n  })\n}\n"]},"metadata":{},"sourceType":"module"}
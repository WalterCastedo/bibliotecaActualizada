{"ast":null,"code":"import { ref, computed, watch } from \"vue\";\n\nfunction useSortable(columns, filteredRows, props, emit) {\n  const sortByFallback = ref(\"\");\n  const sortBySync = computed({\n    get() {\n      if (props.sortBy === void 0) {\n        return sortByFallback.value;\n      } else {\n        return props.sortBy;\n      }\n    },\n\n    set(value) {\n      if (props.sortBy === void 0) {\n        sortByFallback.value = value;\n      }\n\n      emit(\"update:sortBy\", value);\n    }\n\n  });\n  const sortingOrderFallback = ref(null);\n  const sortingOrderSync = computed({\n    get() {\n      if (props.sortingOrder === void 0) {\n        return sortingOrderFallback.value;\n      } else {\n        return props.sortingOrder;\n      }\n    },\n\n    set(value) {\n      if (props.sortingOrder === void 0) {\n        sortingOrderFallback.value = value;\n      }\n\n      emit(\"update:sortingOrder\", value);\n    }\n\n  });\n  const sortedRows = computed(() => {\n    if (filteredRows.value.length <= 1) {\n      return filteredRows.value;\n    }\n\n    const columnIndex = columns.value.findIndex(({\n      name,\n      sortable\n    }) => sortBySync.value === name && sortable);\n    const column = columns.value[columnIndex];\n\n    if (!column) {\n      return filteredRows.value;\n    }\n\n    const sortingOrderRatio = sortingOrderSync.value === \"desc\" ? -1 : 1;\n    return [...filteredRows.value].sort((a, b) => {\n      if (sortingOrderSync.value === null) {\n        return a.initialIndex - b.initialIndex;\n      } else {\n        const firstValue = a.cells[columnIndex].value;\n        const secondValue = b.cells[columnIndex].value;\n        const firstSource = a.cells[columnIndex].source;\n        const secondSource = b.cells[columnIndex].source;\n        return sortingOrderRatio * (typeof column.sortingFn === \"function\" ? column.sortingFn(firstSource, secondSource) : firstValue.localeCompare(secondValue));\n      }\n    });\n  });\n  watch(sortedRows, () => {\n    emit(\"sorted\", {\n      sortBy: sortBySync.value,\n      sortingOrder: sortingOrderSync.value,\n      items: sortedRows.value.map(row => row.source),\n      itemsIndexes: sortedRows.value.map(row => row.initialIndex)\n    });\n  });\n\n  const getNextSortingOptionsValue = (value, options) => {\n    const index = options.findIndex(sortingValue => sortingValue === value);\n    return index !== -1 ? options[(index + 1) % options.length] : options[0];\n  };\n\n  function toggleSorting(column) {\n    if (column.name === sortBySync.value) {\n      sortingOrderSync.value = getNextSortingOptionsValue(sortingOrderSync.value, column.sortingOptions);\n    } else {\n      sortBySync.value = column.name;\n      sortingOrderSync.value = column.sortingOptions[0];\n    }\n  }\n\n  const sortingOrderIconName = computed(() => {\n    return sortingOrderSync.value === \"asc\" ? \"va-arrow-up\" : sortingOrderSync.value === \"desc\" ? \"va-arrow-down\" : \"unfold_more\";\n  });\n  return {\n    sortBySync,\n    sortingOrderSync,\n    toggleSorting,\n    sortedRows,\n    sortingOrderIconName\n  };\n}\n\nexport { useSortable as u };","map":{"version":3,"mappings":"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","names":["filteredRows","props","emit","ref","sortBySync","computed","get","sortBy","sortByFallback","value","set","sortingOrderSync","sortingOrder","sortingOrderFallback","length","columns","findIndex","name","sortable","columnIndex","column","sortingOrderRatio","sort","a","b","initialIndex","cells","source","sortingFn","firstSource","secondSource","firstValue","localeCompare","secondValue","watch","sortedRows","items","map","row","itemsIndexes","options","index","sortingValue","getNextSortingOptionsValue","sortingOptions","toggleSorting","sortingOrderIconName"],"sources":["../../../../../../src/components/va-data-table/hooks/useSortable.ts"],"sourcesContent":["import { computed, ref, Ref, watch } from 'vue'\n\nimport type {\n  DataTableColumnInternal,\n  DataTableRow,\n  DataTableItem,\n  DataTableSortingOrder,\n  DataTableSortingOptions,\n} from '../types'\n\ninterface useSortableProps {\n  sortBy: string | undefined\n  sortingOrder: DataTableSortingOrder | undefined\n}\nexport type TSortedArgs = { sortBy: string, sortingOrder: DataTableSortingOrder, items: DataTableItem[], itemsIndexes: number[] }\nexport type TSortableEmits = (\n  event: 'update:sortBy' | 'update:sortingOrder' | 'sorted',\n  args: string | DataTableSortingOrder | TSortedArgs,\n) => void\n\nexport default function useSortable (\n  columns: Ref<DataTableColumnInternal[]>,\n  filteredRows: Ref<DataTableRow[]>,\n  props: useSortableProps,\n  emit: TSortableEmits,\n) {\n  const sortByFallback = ref('')\n  const sortBySync = computed<string>({\n    get () {\n      if (props.sortBy === undefined) {\n        return sortByFallback.value\n      } else {\n        return props.sortBy\n      }\n    },\n\n    set (value) {\n      if (props.sortBy === undefined) {\n        sortByFallback.value = value\n      }\n\n      emit('update:sortBy', value)\n    },\n  })\n\n  const sortingOrderFallback = ref(null as DataTableSortingOrder)\n  const sortingOrderSync = computed<DataTableSortingOrder>({\n    get () {\n      if (props.sortingOrder === undefined) {\n        return sortingOrderFallback.value\n      } else {\n        return props.sortingOrder\n      }\n    },\n\n    set (value) {\n      if (props.sortingOrder === undefined) {\n        sortingOrderFallback.value = value\n      }\n\n      emit('update:sortingOrder', value)\n    },\n  })\n\n  // sorts by string-value of a given row's cell (depending on by which column the table is sorted) if no sortingFn is\n  // provided. Otherwise uses that very sortingFn. If sortingOrder is `null` then restores the initial sorting order of\n  // the rows.\n  const sortedRows = computed(() => {\n    if (filteredRows.value.length <= 1) {\n      return filteredRows.value\n    }\n\n    const columnIndex = columns.value.findIndex(\n      ({ name, sortable }) => sortBySync.value === name && sortable,\n    )\n    const column = columns.value[columnIndex]\n\n    if (!column) {\n      return filteredRows.value\n    }\n\n    const sortingOrderRatio = sortingOrderSync.value === 'desc' ? -1 : 1\n\n    return [...filteredRows.value].sort((a, b) => {\n      if (sortingOrderSync.value === null) {\n        return a.initialIndex - b.initialIndex\n      } else {\n        const firstValue = a.cells[columnIndex].value\n        const secondValue = b.cells[columnIndex].value\n        const firstSource = a.cells[columnIndex].source\n        const secondSource = b.cells[columnIndex].source\n\n        return sortingOrderRatio * (\n          typeof column.sortingFn === 'function'\n            ? column.sortingFn(firstSource, secondSource)\n            : firstValue.localeCompare(secondValue)\n        )\n      }\n    })\n  })\n\n  // sort each time the sortBy or sortingOrder is changed (and also initially). Also if columns definitions are changed\n  // (because that potentially means that the user runtime-introduced a custom sorting function for a specific column)\n  watch(sortedRows, () => {\n    emit('sorted', {\n      sortBy: sortBySync.value,\n      sortingOrder: sortingOrderSync.value,\n      items: sortedRows.value.map(row => row.source),\n      itemsIndexes: sortedRows.value.map(row => row.initialIndex),\n    })\n  })\n\n  const getNextSortingOptionsValue = (value: DataTableSortingOrder, options: DataTableSortingOptions) => {\n    const index = options.findIndex((sortingValue) => sortingValue === value)\n\n    return index !== -1\n      ? options[(index + 1) % options.length]\n      : options[0]\n  }\n\n  // a function to invoke when a heading of the table is clicked.\n  // Sets the clicked heading's column as a one to sort by and toggles the sorting order from \"asc\" to \"desc\" to `null`\n  // (un-sorted) if the same column is clicked again or sets sorting order to \"asc\" if some other column is chosen.\n  function toggleSorting (column: DataTableColumnInternal) {\n    if (column.name === sortBySync.value) {\n      sortingOrderSync.value = getNextSortingOptionsValue(sortingOrderSync.value, column.sortingOptions)\n    } else {\n      sortBySync.value = column.name\n      sortingOrderSync.value = column.sortingOptions[0]\n    }\n  }\n\n  const sortingOrderIconName = computed(() => {\n    return sortingOrderSync.value === 'asc'\n      ? 'va-arrow-up'\n      : sortingOrderSync.value === 'desc'\n        ? 'va-arrow-down'\n        : 'unfold_more'\n  })\n\n  return {\n    sortBySync,\n    sortingOrderSync,\n    toggleSorting,\n    sortedRows,\n    sortingOrderIconName,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
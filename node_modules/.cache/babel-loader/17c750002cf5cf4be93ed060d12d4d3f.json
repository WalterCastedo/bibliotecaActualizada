{"ast":null,"code":"import { defineComponent, shallowRef, ref, computed, watch, resolveComponent, openBlock, createBlock, resolveDynamicComponent, normalizeClass, withCtx, renderSlot, createElementVNode, createVNode, createCommentVNode } from \"vue\";\nimport { d as debounce_1 } from \"../../../vendor.js\";\nimport { s as sleep } from \"../../utils/sleep.js\";\nimport { u as useColors } from \"../../composables/useColors.js\";\nimport { u as useComponentPresetProp } from \"../../composables/useComponentPreset.js\";\nimport { u as useScroll } from \"./hooks/useScroll.js\";\nimport { V as VaProgressCircle } from \"../va-progress-circle/index.js\";\nimport { _ as _export_sfc } from \"../../../plugin-vue_export-helper.js\";\n\nvar VaInfiniteScroll_vue_vue_type_style_index_0_lang = /* @__PURE__ */(() => \":root{--va-infinite-scroll-display: flex;--va-infinite-scroll-flex-direction: column;--va-infinite-scroll-spinner-default-width: 100%;--va-infinite-scroll-spinner-default-min-height: 70px;--va-infinite-scroll-reversed-flex-direction: column-reverse}.va-infinite-scroll{display:var(--va-infinite-scroll-display);flex-direction:var(--va-infinite-scroll-flex-direction);font-family:var(--va-font-family)}.va-infinite-scroll--reversed{flex-direction:var(--va-infinite-scroll-reversed-flex-direction)}.va-infinite-scroll__spinner{display:flex;justify-content:center;align-items:center}.va-infinite-scroll__spinner__default{display:flex;justify-content:center;align-items:center;width:var(--va-infinite-scroll-spinner-default-width);min-height:var(--va-infinite-scroll-spinner-default-min-height)}.va-infinite-scroll__spinner--invisible{visibility:hidden!important}\\n\")();\n\nconst _sfc_main = defineComponent({\n  name: \"VaInfiniteScroll\",\n  components: {\n    VaProgressCircle\n  },\n  props: { ...useComponentPresetProp,\n    load: {\n      type: Function,\n      required: true\n    },\n    offset: {\n      type: Number,\n      default: 500\n    },\n    reverse: {\n      type: Boolean,\n      default: false\n    },\n    disabled: {\n      type: Boolean,\n      default: false\n    },\n    scrollTarget: {\n      type: [String, Object],\n      default: void 0\n    },\n    debounce: {\n      type: Number,\n      default: 100\n    },\n    tag: {\n      type: String,\n      default: \"div\"\n    }\n  },\n  emits: [\"onload\", \"onerror\"],\n\n  setup(props, {\n    emit\n  }) {\n    const element = shallowRef();\n    const spinnerSlotContainer = shallowRef();\n    const fetching = ref(false);\n    const error = ref(false);\n    const forcedScrolling = ref(false);\n    const debouncedLoad = ref();\n    const notScrolledContentBeforeLoad = ref(0);\n    const prevScrollTop = ref(0);\n    const scrollTargetElement = computed(() => {\n      var _a;\n\n      let target;\n\n      if (typeof props.scrollTarget === \"string\") {\n        target = document.querySelector(props.scrollTarget);\n      } else {\n        target = props.scrollTarget || ((_a = element.value) == null ? void 0 : _a.parentElement);\n      }\n\n      return target || document.body;\n    });\n    const {\n      addScrollListener,\n      removeScrollListener\n    } = useScroll(props, scrollTargetElement, debouncedLoad);\n    const {\n      getColor\n    } = useColors();\n    const spinnerColor = computed(() => {\n      return error.value ? getColor(\"danger\") : getColor(\"primary\");\n    });\n    const spinnerHeight = computed(() => {\n      var _a;\n\n      return ((_a = spinnerSlotContainer.value) == null ? void 0 : _a.offsetHeight) || 0;\n    });\n    const computedOffset = computed(() => {\n      return props.offset + spinnerHeight.value;\n    });\n\n    const stop = () => {\n      if (props.disabled) {\n        return;\n      }\n\n      fetching.value = false;\n      removeScrollListener();\n    };\n\n    const resume = () => {\n      if (props.disabled) {\n        return;\n      }\n\n      addScrollListener();\n    };\n\n    const onLoad = () => {\n      const {\n        scrollTop,\n        scrollHeight,\n        clientHeight\n      } = scrollTargetElement.value;\n      notScrolledContentBeforeLoad.value = scrollHeight - scrollTop;\n      const scrollDelta = scrollTop - prevScrollTop.value;\n      prevScrollTop.value = scrollTop;\n\n      if (props.disabled || error.value || fetching.value) {\n        return;\n      }\n\n      if (forcedScrolling.value) {\n        forcedScrolling.value = false;\n        return;\n      }\n\n      const isReverseScrollDirection = props.reverse && scrollDelta > 0 || !props.reverse && scrollDelta < 0;\n\n      if (isReverseScrollDirection) {\n        return;\n      }\n\n      const offset = props.reverse ? scrollTop : scrollHeight - scrollTop - clientHeight;\n\n      if (offset > computedOffset.value) {\n        return;\n      }\n\n      fetching.value = true;\n      props.load().then(finishLoading).catch(onError);\n    };\n\n    const forceSetScrollTopToTarget = value => {\n      forcedScrolling.value = true;\n      scrollTargetElement.value.scrollTop = value;\n    };\n\n    const updateTargetElementScrollTop = () => {\n      const {\n        scrollTop,\n        scrollHeight,\n        clientHeight\n      } = scrollTargetElement.value;\n\n      if (props.reverse) {\n        const isScrolledUp = scrollHeight - scrollTop < notScrolledContentBeforeLoad.value;\n        const isSpinnerHidden = scrollTop >= spinnerHeight.value;\n\n        if (isScrolledUp && isSpinnerHidden) {\n          return;\n        }\n\n        scrollHeight - notScrolledContentBeforeLoad.value > spinnerHeight.value ? forceSetScrollTopToTarget(scrollHeight - notScrolledContentBeforeLoad.value) : forceSetScrollTopToTarget(spinnerHeight.value);\n      }\n\n      if (!props.reverse) {\n        const isSpinnerHidden = scrollHeight - scrollTop - clientHeight >= spinnerHeight.value;\n        !isSpinnerHidden && forceSetScrollTopToTarget(scrollHeight - clientHeight - spinnerHeight.value);\n      }\n    };\n\n    const finishLoading = () => {\n      updateTargetElementScrollTop();\n      fetching.value = false;\n      emit(\"onload\");\n    };\n\n    const stopErrorDisplay = () => {\n      updateTargetElementScrollTop();\n      forcedScrolling.value = false;\n      error.value = false;\n      fetching.value = false;\n      emit(\"onerror\");\n    };\n\n    const onError = () => {\n      stop();\n      error.value = true;\n      sleep(1200).then(stopErrorDisplay).then(resume);\n    };\n\n    watch(() => props.debounce, value => {\n      debouncedLoad.value = debounce_1(onLoad, value);\n    }, {\n      immediate: true\n    });\n    watch(() => props.disabled, value => {\n      value ? stop() : resume();\n    });\n    return {\n      element,\n      spinnerSlotContainer,\n      spinnerColor,\n      fetching\n    };\n  }\n\n});\n\nconst _hoisted_1 = {\n  class: \"va-infinite-scroll__spinner__default\"\n};\n\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_va_progress_circle = resolveComponent(\"va-progress-circle\");\n\n  return openBlock(), createBlock(resolveDynamicComponent(_ctx.$props.tag), {\n    ref: \"element\",\n    role: \"feed\",\n    class: normalizeClass([\"va-infinite-scroll\", {\n      \"va-infinite-scroll--reversed\": _ctx.$props.reverse\n    }]),\n    \"aria-busy\": _ctx.fetching\n  }, {\n    default: withCtx(() => [renderSlot(_ctx.$slots, \"default\"), createElementVNode(\"div\", {\n      ref: \"spinnerSlotContainer\",\n      class: normalizeClass([\"va-infinite-scroll__spinner\", {\n        \"va-infinite-scroll__spinner--invisible\": !_ctx.fetching\n      }])\n    }, [!_ctx.$props.disabled ? renderSlot(_ctx.$slots, \"loading\", {\n      key: 0\n    }, () => [createElementVNode(\"div\", _hoisted_1, [createVNode(_component_va_progress_circle, {\n      size: \"small\",\n      thickness: 0.15,\n      color: _ctx.spinnerColor,\n      indeterminate: \"\"\n    }, null, 8, [\"thickness\", \"color\"])])]) : createCommentVNode(\"\", true)], 2)]),\n    _: 3\n  }, 8, [\"class\", \"aria-busy\"]);\n}\n\nvar _VaInfiniteScroll = /* @__PURE__ */_export_sfc(_sfc_main, [[\"render\", _sfc_render]]);\n\nexport { _VaInfiniteScroll as _ };\nimport './VaInfiniteScroll.css';","map":{"version":3,"mappings":"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","names":["_sfc_main","defineComponent","name","components","VaProgressCircle","props","useComponentPresetProp","load","type","Function","required","offset","Number","default","reverse","Boolean","disabled","scrollTarget","String","Object","debounce","tag","emits","setup","emit","element","shallowRef","spinnerSlotContainer","ref","debouncedLoad","computed","target","querySelector","value","parentElement","document","body","addScrollListener","removeScrollListener","useScroll","scrollTargetElement","getColor","useColors","error","offsetHeight","spinnerHeight","stop","fetching","resume","onLoad","scrollTop","scrollHeight","clientHeight","notScrolledContentBeforeLoad","prevScrollTop","forcedScrolling","scrollDelta","isReverseScrollDirection","computedOffset","then","finishLoading","catch","onError","updateTargetElementScrollTop","isScrolledUp","isSpinnerHidden","forceSetScrollTopToTarget","stopErrorDisplay","sleep","watch","immediate","spinnerColor","class","_createBlock","_resolveDynamicComponent","_ctx","role","_normalizeClass","_renderSlot","_createElementVNode","$props","key","_createVNode","_component_va_progress_circle","size","thickness","color","indeterminate"],"sources":["../../../../../src/components/va-infinite-scroll/VaInfiniteScroll.vue"],"sourcesContent":["<template>\n  <component\n    :is=\"$props.tag\"\n    ref=\"element\"\n    role=\"feed\"\n    class=\"va-infinite-scroll\"\n    :class=\"{ 'va-infinite-scroll--reversed': $props.reverse }\"\n    :aria-busy=\"fetching\"\n  >\n    <slot name=\"default\" />\n\n    <div\n      ref=\"spinnerSlotContainer\"\n      class=\"va-infinite-scroll__spinner\"\n      :class=\"{ 'va-infinite-scroll__spinner--invisible': !fetching }\"\n    >\n      <slot\n        v-if=\"!$props.disabled\"\n        name=\"loading\"\n      >\n        <div class=\"va-infinite-scroll__spinner__default\">\n          <va-progress-circle\n            size=\"small\"\n            :thickness=\"0.15\"\n            :color=\"spinnerColor\"\n            indeterminate\n          />\n        </div>\n      </slot>\n    </div>\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport { computed, defineComponent, PropType, ref, shallowRef, watch } from 'vue'\nimport debounce from 'lodash/debounce.js'\n\nimport { sleep } from '../../utils/sleep'\nimport { useColors } from '../../composables'\nimport { useScroll } from './hooks/useScroll'\n\nimport { VaProgressCircle } from '../va-progress-circle'\nimport { useComponentPresetProp } from '../../composables/useComponentPreset'\n\nexport default defineComponent({\n  name: 'VaInfiniteScroll',\n\n  components: { VaProgressCircle },\n\n  props: {\n    ...useComponentPresetProp,\n    load: { type: Function, required: true },\n    offset: { type: Number, default: 500 },\n    reverse: { type: Boolean, default: false },\n    disabled: { type: Boolean, default: false },\n    scrollTarget: { type: [String, Object] as PropType<string | HTMLElement>, default: undefined },\n    debounce: { type: Number, default: 100 },\n    tag: { type: String, default: 'div' },\n  },\n\n  emits: ['onload', 'onerror'],\n\n  setup (props, { emit }) {\n    const element = shallowRef<HTMLElement>()\n    const spinnerSlotContainer = shallowRef<HTMLDivElement>()\n\n    const fetching = ref(false)\n    const error = ref(false)\n    const forcedScrolling = ref(false)\n    const debouncedLoad = ref()\n    const notScrolledContentBeforeLoad = ref(0)\n    const prevScrollTop = ref(0)\n\n    const scrollTargetElement = computed<HTMLElement>(() => {\n      let target\n\n      if (typeof props.scrollTarget === 'string') {\n        target = document.querySelector(props.scrollTarget)\n      } else {\n        target = props.scrollTarget || element.value?.parentElement\n      }\n\n      return (target || document.body) as HTMLElement\n    })\n\n    const {\n      addScrollListener,\n      removeScrollListener,\n    } = useScroll(props, scrollTargetElement, debouncedLoad)\n\n    const { getColor } = useColors()\n\n    const spinnerColor = computed(() => {\n      return error.value ? getColor('danger') : getColor('primary')\n    })\n\n    const spinnerHeight = computed(() => {\n      return spinnerSlotContainer.value?.offsetHeight || 0\n    })\n\n    const computedOffset = computed(() => {\n      return props.offset + spinnerHeight.value\n    })\n\n    const stop = () => {\n      if (props.disabled) { return }\n\n      fetching.value = false\n      removeScrollListener()\n    }\n\n    const resume = () => {\n      if (props.disabled) { return }\n\n      addScrollListener()\n    }\n\n    const onLoad = () => {\n      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value\n      notScrolledContentBeforeLoad.value = scrollHeight - scrollTop\n      const scrollDelta = scrollTop - prevScrollTop.value\n      prevScrollTop.value = scrollTop\n\n      if (props.disabled || error.value || fetching.value) { return }\n\n      if (forcedScrolling.value) {\n        forcedScrolling.value = false\n        return\n      }\n\n      const isReverseScrollDirection = (props.reverse && scrollDelta > 0) || (!props.reverse && scrollDelta < 0)\n      if (isReverseScrollDirection) { return }\n\n      const offset = props.reverse ? scrollTop : scrollHeight - scrollTop - clientHeight\n      if (offset > computedOffset.value) { return }\n\n      fetching.value = true\n\n      props.load()\n        .then(finishLoading)\n        .catch(onError)\n    }\n\n    const forceSetScrollTopToTarget = (value: number) => {\n      forcedScrolling.value = true\n      scrollTargetElement.value.scrollTop = value\n    }\n\n    const updateTargetElementScrollTop = () => {\n      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value\n\n      if (props.reverse) {\n        const isScrolledUp = scrollHeight - scrollTop < notScrolledContentBeforeLoad.value\n        const isSpinnerHidden = scrollTop >= spinnerHeight.value\n\n        if (isScrolledUp && isSpinnerHidden) { return }\n\n        (scrollHeight - notScrolledContentBeforeLoad.value > spinnerHeight.value)\n          ? forceSetScrollTopToTarget(scrollHeight - notScrolledContentBeforeLoad.value)\n          : forceSetScrollTopToTarget(spinnerHeight.value)\n      }\n\n      if (!props.reverse) {\n        const isSpinnerHidden = scrollHeight - scrollTop - clientHeight >= spinnerHeight.value\n        !isSpinnerHidden && forceSetScrollTopToTarget(scrollHeight - clientHeight - spinnerHeight.value)\n      }\n    }\n\n    const finishLoading = () => {\n      updateTargetElementScrollTop()\n      fetching.value = false\n      emit('onload')\n    }\n\n    const stopErrorDisplay = () => {\n      updateTargetElementScrollTop()\n      forcedScrolling.value = false\n      error.value = false\n      fetching.value = false\n      emit('onerror')\n    }\n\n    const onError = () => {\n      stop()\n      error.value = true\n\n      sleep(1200)\n        .then(stopErrorDisplay)\n        .then(resume)\n    }\n\n    watch(() => props.debounce, (value) => {\n      debouncedLoad.value = debounce(onLoad, value)\n    }, { immediate: true })\n\n    watch(() => props.disabled, (value) => {\n      value ? stop() : resume()\n    })\n\n    return {\n      element,\n      spinnerSlotContainer,\n\n      spinnerColor,\n      fetching,\n    }\n  },\n})\n</script>\n\n<style lang=\"scss\">\n@import \"../../styles/resources\";\n@import 'variables';\n\n.va-infinite-scroll {\n  display: var(--va-infinite-scroll-display);\n  flex-direction: var(--va-infinite-scroll-flex-direction);\n  font-family: var(--va-font-family);\n\n  &--reversed {\n    flex-direction: var(--va-infinite-scroll-reversed-flex-direction);\n  }\n\n  &__spinner {\n    &__default {\n      @include flex-center();\n\n      width: var(--va-infinite-scroll-spinner-default-width);\n      min-height: var(--va-infinite-scroll-spinner-default-min-height);\n    }\n\n    &--invisible {\n      visibility: hidden !important;\n    }\n\n    @include flex-center();\n  }\n}\n</style>\n"]},"metadata":{},"sourceType":"module"}
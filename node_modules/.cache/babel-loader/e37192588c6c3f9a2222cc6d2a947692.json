{"ast":null,"code":"import { computed } from \"vue\";\n\nconst useParsable = (parsable, parse, format) => {\n  const text = computed({\n    get() {\n      const value2 = parsable.value;\n\n      if (typeof value2 === \"string\") {\n        return value2;\n      }\n\n      return format(value2);\n    },\n\n    set(v) {\n      if (typeof parsable.value === \"string\") {\n        parsable.value = v;\n      } else {\n        parsable.value = parse(v);\n      }\n    }\n\n  });\n  const value = computed({\n    get() {\n      if (typeof parsable.value === \"string\") {\n        return parse(parsable.value);\n      }\n\n      return parsable.value;\n    },\n\n    set(v) {\n      if (typeof parsable.value === \"string\") {\n        parsable.value = format(v);\n      } else {\n        parsable.value = v;\n      }\n    }\n\n  });\n  return {\n    text,\n    value\n  };\n};\n\nexport { useParsable as u };","map":{"version":3,"mappings":";;AAIO,MAAMA,cAAc,CACzBC,QADyB,EAEzBC,KAFyB,EAGzBC,MAHyB,KAItB;EACH,MAAMC,OAAOC,SAAS;IACpBC,MAAO;MACL,MAAMC,SAAQN,SAASO,KAAvB;;MACI,WAAOD,MAAP,KAAiB,QAAjB,EAA2B;QACtB;MACT;;MACA,OAAOJ,OAAOI,MAAP,CAAP;IACF,CAPoB;;IAQpBE,IAAKC,CAAL,EAAc;MACR,WAAOT,SAASO,KAAhB,KAA0B,QAA1B,EAAoC;QACtCP,SAASO,KAAT,GAAiBE,CAAjB;MAAiB,CADf,MAEG;QACIT,iBAAQC,MAAMQ,CAAN,CAAR;MACX;IACF;;EAdoB,CAAT,CAAb;EAiBA,MAAMF,QAAQH,SAAgB;IAC5BC,MAAO;MACD,WAAOL,SAASO,KAAhB,KAA0B,QAA1B,EAAoC;QAC/B,aAAMP,SAASO,KAAf;MACT;;MAEA,OAAOP,SAASO,KAAhB;IACF,CAP4B;;IAQ5BC,IAAKC,CAAL,EAAe;MACT,WAAOT,SAASO,KAAhB,KAA0B,QAA1B,EAAoC;QAC7BP,iBAAQE,OAAOO,CAAP,CAAR;MAAuB,CAD9B,MAEG;QACLT,SAASO,KAAT,GAAiBE,CAAjB;MACF;IACF;;EAd4B,CAAhB,CAAd;EAiBO;IACLN,IADK;IAELI;EAFK;AAIT,CA3CO","names":["useParsable","parsable","parse","format","text","computed","get","value2","value","set","v"],"sources":["../../../../src/composables/useParsable.ts"],"sourcesContent":["import { computed, Ref } from 'vue'\n\ntype Not<P, N> = P extends N ? never : P\n\nexport const useParsable = <Text extends string | number, Original, Value extends Not<Original, Text>>(\n  parsable: Ref<Original>,\n  parse: (t: Text) => Value,\n  format: (v: Value) => Text,\n) => {\n  const text = computed({\n    get () {\n      const value = parsable.value\n      if (typeof value === 'string') {\n        return value as any\n      }\n      return format(value as Value)\n    },\n    set (v: Text) {\n      if (typeof parsable.value === 'string') {\n        parsable.value = v as any\n      } else {\n        parsable.value = parse(v)\n      }\n    },\n  })\n\n  const value = computed<Value>({\n    get () {\n      if (typeof parsable.value === 'string') {\n        return parse(parsable.value as any)\n      }\n\n      return parsable.value as Value\n    },\n    set (v: Value) {\n      if (typeof parsable.value === 'string') {\n        parsable.value = format(v as any) as any\n      } else {\n        parsable.value = v\n      }\n    },\n  })\n\n  return {\n    text,\n    value,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
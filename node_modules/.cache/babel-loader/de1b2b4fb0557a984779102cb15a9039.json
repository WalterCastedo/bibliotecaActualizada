{"ast":null,"code":"import { ref, computed, watch } from \"vue\";\nimport { i as isRange, p as parseModelValue } from \"./model-value-parser.js\";\n\nconst useRangeModelValueGuard = (modelValue, disabled, parseValue = parseModelValue) => {\n  const bufferValue = ref(modelValue.value && parseValue(modelValue.value));\n  const valueComputed = computed({\n    get: () => bufferValue.value,\n    set: value => {\n      if (disabled.value) {\n        modelValue.value = value;\n      }\n\n      if (!value) {\n        modelValue.value = value;\n        return;\n      }\n\n      if (isRange(value)) {\n        if (value.end !== null) {\n          modelValue.value = value;\n        }\n      } else {\n        modelValue.value = value;\n      }\n\n      bufferValue.value = value;\n    }\n  });\n  watch(modelValue, newValue => {\n    bufferValue.value = newValue;\n  });\n\n  const reset = () => {\n    if (bufferValue.value && isRange(bufferValue.value)) {\n      bufferValue.value = modelValue.value && parseValue(modelValue.value);\n    }\n  };\n\n  return {\n    valueComputed,\n    reset\n  };\n};\n\nexport { useRangeModelValueGuard as u };","map":{"version":3,"mappings":";;;AASO,MAAMA,0BAA0B,CACrCC,UADqC,EAErCC,QAFqC,EAGrCC,aAAaC,eAHwB,KAIlC;EACH,MAAMC,cAAcC,IAAyBL,WAAWM,KAAX,IAAoBJ,WAAWF,WAAWM,KAAtB,CAA7C,CAApB;EAEA,MAAMC,gBAAgBC,SAAS;IAC7BC,KAAK,MAAML,YAAYE,KADM;IAE7BI,KAAMJ,KAAD,IAAW;MACd,IAAIL,SAASK,KAAb,EAAoB;QAClBN,WAAWM,KAAX,GAAmBA,KAAnB;MACF;;MAEA,IAAI,CAACA,KAAL,EAAY;QACVN,WAAWM,KAAX,GAAmBA,KAAnB;QACA;MACF;;MAEI,YAAQA,KAAR,GAAgB;QACd,UAAMK,GAAN,KAAc,IAAd,EAAoB;UACtBX,WAAWM,KAAX,GAAmBA,KAAnB;QACF;MAAA,CAHE,MAIG;QACLN,WAAWM,KAAX,GAAmBA,KAAnB;MACF;;MAEAF,YAAYE,KAAZ,GAAoBA,KAApB;IACF;EArB6B,CAAT,CAAtB;EAwBMM,kBAAaC,QAAD,IAAc;IAC9BT,YAAYE,KAAZ,GAAoBO,QAApB;EACD,CAFK;;EAIN,MAAMC,QAAQ,MAAM;IAClB,IAAIV,YAAYE,KAAZ,IAAqBS,QAAQX,YAAYE,KAApB,CAAzB,EAAqD;MACnDF,YAAYE,KAAZ,GAAoBN,WAAWM,KAAX,IAAoBJ,WAAWF,WAAWM,KAAtB,CAAxC;IACF;EAAA,CAHF;;EAMO;IACLC,aADK;IAELO;EAFK;AAIT,CA7CO","names":["useRangeModelValueGuard","modelValue","disabled","parseValue","parseModelValue","bufferValue","ref","value","valueComputed","computed","get","set","end","watch","newValue","reset","isRange"],"sources":["../../../../../../src/components/va-date-input/hooks/range-model-value-guard.ts"],"sourcesContent":["import { computed, Ref, ref, watch } from 'vue'\n\nimport { parseModelValue, isRange } from './model-value-parser'\nimport { DateInputModelValue } from '../types'\n\n/**\n * This guard is used to prevent updating modelValue if range end is not specified.\n * This guard provides reset method, that allow us to reset VaDateInput value if dropdown is closed.\n */\nexport const useRangeModelValueGuard = (\n  modelValue: Ref<DateInputModelValue>,\n  disabled: Ref<boolean>,\n  parseValue = parseModelValue,\n) => {\n  const bufferValue = ref<DateInputModelValue>(modelValue.value && parseValue(modelValue.value))\n\n  const valueComputed = computed({\n    get: () => bufferValue.value,\n    set: (value) => {\n      if (disabled.value) {\n        modelValue.value = value\n      }\n\n      if (!value) {\n        modelValue.value = value\n        return\n      }\n\n      if (isRange(value)) {\n        if (value.end !== null) {\n          modelValue.value = value\n        }\n      } else {\n        modelValue.value = value\n      }\n\n      bufferValue.value = value\n    },\n  })\n\n  watch(modelValue, (newValue) => {\n    bufferValue.value = newValue\n  })\n\n  const reset = () => {\n    if (bufferValue.value && isRange(bufferValue.value)) {\n      bufferValue.value = modelValue.value && parseValue(modelValue.value)\n    }\n  }\n\n  return {\n    valueComputed,\n    reset,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { computed, unref, isRef, reactive } from \"vue\";\n\nconst useReactiveComputed = obj => {\n  const objectRef = typeof obj === \"function\" ? computed(obj) : computed(obj);\n  const proxy = new Proxy({}, {\n    get(target, p, receiver) {\n      return unref(Reflect.get(objectRef.value, p, receiver));\n    },\n\n    set(target, p, value) {\n      if (isRef(objectRef.value[p]) && !isRef(value)) {\n        objectRef.value[p].value = value;\n      } else {\n        objectRef.value[p] = value;\n      }\n\n      return true;\n    },\n\n    deleteProperty(target, p) {\n      return Reflect.deleteProperty(objectRef.value, p);\n    },\n\n    has(target, p) {\n      return Reflect.has(objectRef.value, p);\n    },\n\n    ownKeys() {\n      return Object.keys(objectRef.value);\n    },\n\n    getOwnPropertyDescriptor() {\n      return {\n        enumerable: true,\n        configurable: true\n      };\n    }\n\n  });\n  return reactive(proxy);\n};\n\nexport { useReactiveComputed as u };","map":{"version":3,"mappings":";;AAEa,4BAAyCA,GAAnB,IAA2E;EACtG,kBAAY,OAAOA,GAAP,KAAe,UAAf,GAA4BC,SAASD,GAAT,CAA5B,GAAiEC,SAASD,GAAT,CAA7E;EAEN,MAAME,QAAQ,IAAIC,KAAJ,CAAU,EAAV,EAAc;IAC1BC,IAAKC,MAAL,EAAaC,CAAb,EAAwBC,QAAxB,EAAkC;MAChC,OAAOC,MAAMC,QAAQL,GAAR,CAAYM,UAAUC,KAAtB,EAA6BL,CAA7B,EAAgCC,QAAhC,CAAN,CAAP;IACF,CAH0B;;IAI1BK,IAAKP,MAAL,EAAaC,CAAb,EAAgBK,KAAhB,EAAuB;MACjB,UAAOD,UAAUC,KAAV,CAAwBL,CAAxB,CAAP,KAAsC,CAACO,MAAMF,KAAN,CAAvC,EAAqD;QACtDD,UAAUC,KAAV,CAAwBL,CAAxB,EAA2BK,KAA3B,GAAmCA,KAAnC;MAAmC,CADlC,MAEG;QACJD,UAAUC,KAAV,CAAwBL,CAAxB,IAA6BK,KAA7B;MACH;;MACO;IACT,CAX0B;;IAY1BG,eAAgBT,MAAhB,EAAwBC,CAAxB,EAA2B;MACzB,OAAOG,QAAQK,cAAR,CAAuBJ,UAAUC,KAAjC,EAAwCL,CAAxC,CAAP;IACF,CAd0B;;IAe1BS,IAAKV,MAAL,EAAaC,CAAb,EAAgB;MACd,OAAOG,QAAQM,GAAR,CAAYL,UAAUC,KAAtB,EAA6BL,CAA7B,CAAP;IACF,CAjB0B;;IAkB1BU,UAAW;MACF,cAAOC,IAAP,CAAYP,UAAUC,KAAtB;IACT,CApB0B;;IAqB1BO,2BAA4B;MACnB;QACLC,YAAY,IADP;QAELC,cAAc;MAFT;IAIT;;EA1B0B,CAAd,CAAd;EA6BA,OAAOC,SAASnB,KAAT,CAAP;AACF,CAjCa","names":["obj","computed","proxy","Proxy","get","target","p","receiver","unref","Reflect","objectRef","value","set","isRef","deleteProperty","has","ownKeys","keys","getOwnPropertyDescriptor","enumerable","configurable","reactive"],"sources":["../../../../src/composables/useReactiveComputed.ts"],"sourcesContent":["import { computed, unref, WritableComputedOptions, ComputedGetter, isRef, reactive } from 'vue'\n\nexport const useReactiveComputed = <T extends object>(obj: WritableComputedOptions<T> | ComputedGetter<T>) => {\n  const objectRef = typeof obj === 'function' ? computed(obj as ComputedGetter<T>) : computed(obj as WritableComputedOptions<T>)\n\n  const proxy = new Proxy({}, {\n    get (target, p: string, receiver) {\n      return unref(Reflect.get(objectRef.value, p, receiver))\n    },\n    set (target, p, value) {\n      if (isRef((objectRef.value as any)[p]) && !isRef(value)) {\n        (objectRef.value as any)[p].value = value\n      } else {\n        (objectRef.value as any)[p] = value\n      }\n      return true\n    },\n    deleteProperty (target, p) {\n      return Reflect.deleteProperty(objectRef.value, p)\n    },\n    has (target, p) {\n      return Reflect.has(objectRef.value, p)\n    },\n    ownKeys () {\n      return Object.keys(objectRef.value)\n    },\n    getOwnPropertyDescriptor () {\n      return {\n        enumerable: true,\n        configurable: true,\n      }\n    },\n  })\n\n  return reactive(proxy) as T\n}\n"]},"metadata":{},"sourceType":"module"}
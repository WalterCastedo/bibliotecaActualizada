{"ast":null,"code":"import { ref, watch, computed } from \"vue\";\nconst useStatefulProps = {\n  stateful: {\n    type: Boolean,\n    default: false\n  },\n  modelValue: {\n    type: void 0\n  }\n};\n\nconst createStatefulProps = (modelValueType, statefulDefault = false) => {\n  return {\n    stateful: {\n      type: Boolean,\n      default: statefulDefault\n    },\n    modelValue: {\n      type: modelValueType\n    }\n  };\n};\n\nconst useStatefulEmits = [\"update:modelValue\"];\n\nconst useStateful = (props, emit, key = \"modelValue\", options = {}) => {\n  const {\n    defaultValue,\n    eventName\n  } = options;\n  const event = eventName || `update:${key.toString()}`;\n  const valueState = ref(defaultValue === void 0 ? props[key] : defaultValue);\n  let unwatchModelValue;\n\n  const watchModelValue = () => {\n    unwatchModelValue = watch(() => props[key], modelValue => {\n      valueState.value = modelValue;\n    });\n  };\n\n  watch(() => props.stateful, stateful => {\n    stateful ? watchModelValue() : unwatchModelValue == null ? void 0 : unwatchModelValue();\n  }, {\n    immediate: true\n  });\n  const valueComputed = computed({\n    get: () => {\n      if (props.stateful) {\n        return valueState.value;\n      }\n\n      return props[key];\n    },\n    set: value => {\n      if (props.stateful) {\n        valueState.value = value;\n      }\n\n      emit(event, value);\n    }\n  });\n  return {\n    valueComputed\n  };\n};\n\nexport { useStatefulProps as a, useStateful as b, createStatefulProps as c, useStatefulEmits as u };","map":{"version":3,"mappings":";AAkBO,MAAMA,mBAAmB;EAC9BC,UAAU;IAAEC,MAAMC,OAAR;IAAsCC,SAAS;EAA/C,CADoB;EAE9BC,YAAY;IAAEH,MAAM;EAAR;AAFkB,CAAzB;;AAKA,MAAMI,sBAAsB,CAAIC,cAAJ,EAAwBC,kBAAkB,KAA1C,KAAoD;EAC9E;IACLP,UAAU;MAAEC,MAAMC,OAAR;MAAsCC,SAASI;IAA/C,CADL;IAELH,YAAY;MAAEH,MAAMK;IAAR;EAFP;AAIT,CALO;;AAOM,yBAAmB,CAAC,mBAAD,CAAnB;;AAOA,oBAAc,CACzBE,KADyB,EAEzBC,IAFyB,EAGzBC,MAAW,YAHc,EAIzBC,UAAU,EAJe,KAKtB;EACG;IAAEC,YAAF;IAAgBC;EAAhB,IAA8BF,OAA9B;EACN,MAAMG,QAASD,aAAa,UAAUH,IAAIK,QAAJ,EAAa,EAAnD;EACA,MAAMC,aAAaC,IAAIL,iBAAiB,MAAjB,GAA6BJ,MAAME,GAAN,CAA7B,GAA0CE,YAA9C,CAAnB;EACI;;EAEJ,MAAMM,kBAAkB,MAAM;IAC5BC,oBAAoBC,MAAM,MAAMZ,MAAME,GAAN,CAAZ,EAAyBN,UAAD,IAAgB;MAC1DY,WAAWK,KAAX,GAAmBjB,UAAnB;IACD,CAFmB,CAApB;EAEC,CAHH;;EAMAgB,MAAM,MAAMZ,MAAMR,QAAlB,EAA6BA,QAAD,IAAuB;IACtCA,+BAAoBmB,wDAApB;EAAwC,CADrD,EAEG;IAAEG,WAAW;EAAb,CAFH;EAIA,MAAMC,gBAAgBC,SAAS;IAC7BC,KAAK,MAAM;MACT,IAAIjB,MAAMR,QAAV,EAAoB;QAAE,OAAOgB,WAAWK,KAAlB;MAAwB;;MAE9C,OAAOb,MAAME,GAAN,CAAP;IACF,CAL6B;IAM7BgB,KAAML,KAAD,IAAW;MACd,IAAIb,MAAMR,QAAV,EAAoB;QAAEgB,WAAWK,KAAX,GAAmBA,KAAnB;MAAyB;;MAE/CZ,KAAKK,KAAL,EAAYO,KAAZ;IACF;EAV6B,CAAT,CAAtB;EAaA,OAAO;IAAEE;EAAF,CAAP;AACF,CAnCa","names":["useStatefulProps","stateful","type","Boolean","default","modelValue","createStatefulProps","modelValueType","statefulDefault","props","emit","key","options","defaultValue","eventName","event","toString","valueState","ref","watchModelValue","unwatchModelValue","watch","value","immediate","valueComputed","computed","get","set"],"sources":["../../../../src/composables/useStateful.ts"],"sourcesContent":["import { ref, computed, watch, PropType, Ref } from 'vue'\n\nexport type StatefulProps = {\n  stateful: boolean\n  [key: string]: any\n}\n\nexport type StatefulOptions<T> = {\n  eventName?: string\n  defaultValue: T\n}\n\n/**\n * You could add these props to any component by destructuring them inside props option.\n * @example\n * props: { ...useStatefulProps, componentsOwnProp, etc. }\n * It's better to add props at the beginning, to make sure that Component own props will be used instead in case of collision\n */\nexport const useStatefulProps = {\n  stateful: { type: Boolean as PropType<boolean>, default: false },\n  modelValue: { type: undefined as any },\n}\n\nexport const createStatefulProps = <T>(modelValueType?: T, statefulDefault = false) => {\n  return {\n    stateful: { type: Boolean as PropType<boolean>, default: statefulDefault },\n    modelValue: { type: modelValueType },\n  }\n}\n\nexport const useStatefulEmits = ['update:modelValue']\n\n/**\n * Returns `valueComputed` that is proxy for `modelValue` or given key of the props\n * if `stateful` prop is `false`\n * Record<any, any> & Record<'modelValue', T>\n */\nexport const useStateful = <Props extends StatefulProps, Name extends string, Key extends keyof Props>(\n  props: Props,\n  emit: (name: Name, ...args: any[]) => void,\n  key: Key = 'modelValue' as Key,\n  options = {} as StatefulOptions<Props[Key]>,\n) => {\n  const { defaultValue, eventName } = options\n  const event = (eventName || `update:${key.toString()}`) as Name\n  const valueState = ref(defaultValue === undefined ? props[key] : defaultValue) as Ref\n  let unwatchModelValue: Function\n\n  const watchModelValue = () => {\n    unwatchModelValue = watch(() => props[key], (modelValue) => {\n      valueState.value = modelValue\n    })\n  }\n\n  watch(() => props.stateful, (stateful: boolean) => {\n    stateful ? watchModelValue() : unwatchModelValue?.()\n  }, { immediate: true })\n\n  const valueComputed = computed({\n    get: () => {\n      if (props.stateful) { return valueState.value }\n\n      return props[key]\n    },\n    set: (value) => {\n      if (props.stateful) { valueState.value = value }\n\n      emit(event, value)\n    },\n  })\n\n  return { valueComputed }\n}\n"]},"metadata":{},"sourceType":"module"}
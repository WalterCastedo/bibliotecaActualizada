{"ast":null,"code":"import { computed, watch } from \"vue\";\n\nfunction useFilterable(rawRows, props, emit) {\n  const filteredRows = computed(() => {\n    if (!rawRows.value.length) {\n      return rawRows.value;\n    }\n\n    if (props.filter === \"\" && !props.filterMethod) {\n      return rawRows.value;\n    }\n\n    return rawRows.value.filter(row => row.cells.some(cell => {\n      return typeof props.filterMethod === \"function\" ? props.filterMethod(cell.source) : cell.value.toLowerCase().includes(props.filter.toLowerCase());\n    }));\n  });\n  watch(filteredRows, () => {\n    emit(\"filtered\", {\n      items: filteredRows.value.map(row => row.source),\n      itemsIndexes: filteredRows.value.map(row => row.initialIndex)\n    });\n  });\n  return {\n    filteredRows\n  };\n}\n\nexport { useFilterable as u };","map":{"version":3,"mappings":";;AAcE,gCACAA,KADA,EAEAC,IAFA,EAGA;EACM,qBAAeC,SAAyB,MAAM;IAC9C,KAACC,QAAQC,KAAR,CAAcC,MAAf,EAAuB;MACzB,OAAOF,QAAQC,KAAf;IACF;;IAEA,IAAIJ,MAAMM,MAAN,KAAiB,EAAjB,IAAuB,CAACN,MAAMO,YAAlC,EAAgD;MAC9C,OAAOJ,QAAQC,KAAf;IACF;;IAEA,OAAOD,QAAQC,KAAR,CAAcE,MAAd,CAAqBE,OAAOA,IAAIC,KAAJ,CAAUC,IAAV,CAAuBC,IAAR,IAAQ;MACxD,OAAO,OAAOX,MAAMO,YAAb,KAA8B,UAA9B,GACHP,MAAMO,YAAN,CAAmBI,KAAKC,MAAxB,CADG,GAEHD,KAAKP,KAAL,CAAWS,WAAX,GAAyBC,QAAzB,CAAkCd,MAAMM,MAAN,CAAaO,WAAb,EAAlC,CAFJ;IAGD,CAJkC,CAA5B,CAAP;EAKD,CAdoB,CAAf;EAgBNE,MAAMC,YAAN,EAAoB,MAAM;IACxBf,KAAK,UAAL,EAAiB;MACfgB,OAAOD,aAAaZ,KAAb,CAAmBc,GAAnB,CAAuBV,OAAOA,IAAII,MAAlC,CADQ;MAEfO,cAAcH,aAAaZ,KAAb,CAAmBc,GAAnB,CAAuBV,OAAOA,IAAIY,YAAlC;IAFC,CAAjB;EAID,CALD;EAOO;IACLJ;EADK;AAGT","names":["props","emit","computed","rawRows","value","length","filter","filterMethod","row","cells","some","cell","source","toLowerCase","includes","watch","filteredRows","items","map","itemsIndexes","initialIndex"],"sources":["../../../../../../src/components/va-data-table/hooks/useFilterable.ts"],"sourcesContent":["import { Ref, watch, computed } from 'vue'\n\nimport type { DataTableRow, DataTableFilterMethod, DataTableItem } from '../types'\n\ninterface useFilterableProps {\n  filter: string\n  filterMethod: DataTableFilterMethod | undefined\n  [prop: string]: unknown\n}\n\nexport type TFilteredArgs = { items: DataTableItem[], itemsIndexes: number[] }\nexport type TFilterableEmits = (event: 'filtered', arg: TFilteredArgs) => void\n\nexport default function useFilterable (\n  rawRows: Ref<DataTableRow[]>,\n  props: useFilterableProps,\n  emit: TFilterableEmits,\n) {\n  const filteredRows = computed<DataTableRow[]>(() => {\n    if (!rawRows.value.length) {\n      return rawRows.value\n    }\n\n    if (props.filter === '' && !props.filterMethod) {\n      return rawRows.value\n    }\n\n    return rawRows.value.filter(row => row.cells.some(cell => {\n      return typeof props.filterMethod === 'function'\n        ? props.filterMethod(cell.source)\n        : cell.value.toLowerCase().includes(props.filter.toLowerCase())\n    }))\n  })\n\n  watch(filteredRows, () => {\n    emit('filtered', {\n      items: filteredRows.value.map(row => row.source),\n      itemsIndexes: filteredRows.value.map(row => row.initialIndex),\n    })\n  })\n\n  return {\n    filteredRows,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
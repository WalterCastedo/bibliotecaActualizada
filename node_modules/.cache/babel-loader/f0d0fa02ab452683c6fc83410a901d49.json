{"ast":null,"code":"import { u as useDomChangesObserver } from \"./useDomChangesObserver.js\";\nimport { g as getElementBackground } from \"./utils.js\";\nimport { ref, onMounted } from \"vue\";\nimport { u as useColors } from \"../useColors.js\";\nimport { u as useEl } from \"../useEl.js\";\nimport { T as TempMap } from \"./TempMap.js\";\nimport { e as applyColors } from \"../../services/color/utils.js\";\n\nconst isTransparent = color => color === \"rgba(0, 0, 0, 0)\";\n\nconst withCache = cb => {\n  return (element, cache) => {\n    if (!element) {\n      return \"#fff\";\n    }\n\n    if (cache.has(element)) {\n      return cache.get(element);\n    }\n\n    cache.set(element, cb(element, cache));\n    return cache.get(element);\n  };\n};\n\nconst tempCache = new TempMap();\n\nconst useElementBackground = element => {\n  const el = element || useEl();\n  const {\n    getColor\n  } = useColors();\n  const background = ref(getColor(\"background-primary\"));\n  const recursiveGetBackground = withCache((element2, cache) => {\n    if (!element2) {\n      return \"#fff\";\n    }\n\n    if (element2.nodeType !== Node.ELEMENT_NODE) {\n      return recursiveGetBackground(element2.parentElement, cache);\n    }\n\n    const bg = getElementBackground(element2);\n\n    if (!bg) {\n      return recursiveGetBackground(element2.parentElement, cache);\n    }\n\n    if (isTransparent(bg)) {\n      return recursiveGetBackground(element2.parentElement, cache);\n    }\n\n    return applyColors(recursiveGetBackground(element2.parentElement, cache), bg);\n  });\n\n  const updateBackground = (cache = tempCache) => {\n    background.value = recursiveGetBackground(el.value, cache);\n  };\n\n  useDomChangesObserver(updateBackground, el);\n  onMounted(updateBackground);\n  return {\n    background\n  };\n};\n\nexport { useElementBackground as u };","map":{"version":3,"mappings":";;;;;;;;AAUA,MAAMA,gBAAiBC,KAAD,IAAmBA,UAAU,kBAAnD;;AAEA,MAAMC,YAAaC,EAAD,IAAwD;EACjE,QAACC,OAAD,EAA8BC,KAA9B,KAA+C;IACpD,IAAI,CAACD,OAAL,EAAc;MAAS;IAAO;;IAC1B,UAAME,GAAN,CAAUF,OAAV,GAAoB;MAAS,aAAMG,GAAN,CAAUH,OAAV;IAAoB;;IACrDC,MAAMG,GAAN,CAAUJ,OAAV,EAAmBD,GAAGC,OAAH,EAAYC,KAAZ,CAAnB;IACO,aAAME,GAAN,CAAUH,OAAV;EAAiB,CAJnB;AAMT,CAPA;;AASA,MAAMK,YAAY,IAAIC,OAAJ,EAAlB;;AAGa,6BAAwBN,OAAD,IAA4C;EACxE,WAAKA,WAAWO,OAAhB;EACA;IAAEC;EAAF,IAAeC,WAAf;EACN,MAAMC,aAAaC,IAAIH,SAAS,oBAAT,CAAJ,CAAnB;EAEA,MAAMI,yBAAyBd,UAAU,CAACe,QAAD,EAAUZ,KAAV,KAA4B;IACnE,IAAI,CAACY,QAAL,EAAc;MAAS;IAAO;;IAC1B,aAAQC,QAAR,KAAqBC,KAAKC,YAA1B,EAAwC;MAAS,8BAAuBH,SAAQI,aAA/B,EAA8ChB,KAA9C;IAAqD;;IAEpG,WAAKiB,qBAAqBL,QAArB,CAAL;;IAEN,IAAI,CAACM,EAAL,EAAS;MAAS,8BAAuBN,SAAQI,aAA/B,EAA8ChB,KAA9C;IAAqD;;IAEnE,kBAAckB,EAAd,GAAmB;MACd,8BAAuBN,SAAQI,aAA/B,EAA8ChB,KAA9C;IACT;;IAEA,OAAOmB,YAAYR,uBAAuBC,SAAQI,aAA/B,EAA8ChB,KAA9C,CAAZ,EAAkEkB,EAAlE,CAAP;EACD,CAb8B,CAA/B;;EAeM,yBAAmB,CAAClB,QAAeI,SAAhB,KAA8B;IACrDK,WAAWW,KAAX,GAAmBT,uBAAuBU,GAAGD,KAA1B,EAAiCpB,KAAjC,CAAnB;EAAyD,CADrD;;EAINsB,sBAAsBC,gBAAtB,EAAwCF,EAAxC;EAEAG,UAAUD,gBAAV;EAEO;IACLd;EADK;AAGT,CA/Ba","names":["isTransparent","color","withCache","cb","element","cache","has","get","set","tempCache","TempMap","useEl","getColor","useColors","background","ref","recursiveGetBackground","element2","nodeType","Node","ELEMENT_NODE","parentElement","getElementBackground","bg","applyColors","value","el","useDomChangesObserver","updateBackground","onMounted"],"sources":["../../../../../src/composables/useElementBackground/useElementBackground.ts"],"sourcesContent":["import { useDomChangesObserver } from './useDomChangesObserver'\nimport { getElementBackground } from './utils'\nimport { ref, Ref, onMounted } from 'vue'\nimport { applyColors, useColors } from '../useColors'\nimport { useEl } from '../useEl'\nimport { TempMap } from './TempMap'\n\ntype Maybe<T> = T | null | undefined\ntype Cache = Map<HTMLElement, string>\n\nconst isTransparent = (color: string) => color === 'rgba(0, 0, 0, 0)'\n\nconst withCache = (cb: (element: HTMLElement, cache: Cache) => string) => {\n  return (element: Maybe<HTMLElement>, cache: Cache) => {\n    if (!element) { return '#fff' }\n    if (cache.has(element)) { return cache.get(element)! }\n    cache.set(element, cb(element, cache))\n    return cache.get(element)!\n  }\n}\n\nconst tempCache = new TempMap<HTMLElement, string>()\n\n/** Can be null before component is mounted */\nexport const useElementBackground = (element?: Ref<HTMLElement | undefined>) => {\n  const el = element || useEl()\n  const { getColor } = useColors()\n  const background = ref(getColor('background-primary'))\n\n  const recursiveGetBackground = withCache((element, cache): string => {\n    if (!element) { return '#fff' } // Likely doesn't have a color, so let's just return white\n    if (element.nodeType !== Node.ELEMENT_NODE) { return recursiveGetBackground(element.parentElement, cache) }\n\n    const bg = getElementBackground(element)\n\n    if (!bg) { return recursiveGetBackground(element.parentElement, cache) }\n\n    if (isTransparent(bg)) {\n      return recursiveGetBackground(element.parentElement, cache)\n    }\n\n    return applyColors(recursiveGetBackground(element.parentElement, cache), bg)\n  })\n\n  const updateBackground = (cache: Cache = tempCache) => {\n    background.value = recursiveGetBackground(el.value, cache)\n  }\n\n  useDomChangesObserver(updateBackground, el)\n\n  onMounted(updateBackground)\n\n  return {\n    background,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
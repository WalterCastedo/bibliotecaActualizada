{"ast":null,"code":"import { l as isObject_1 } from \"../../vendor.js\";\n\nconst getNestedValue = (option, propsArray) => {\n  if (propsArray.length === 0) {\n    return option;\n  }\n\n  const nestedItem = option[propsArray[0]];\n\n  if (!isObject_1(nestedItem)) {\n    if (propsArray.length === 1) {\n      return nestedItem;\n    }\n\n    return void 0;\n  }\n\n  return getNestedValue(nestedItem, propsArray.slice(1));\n};\n\nconst getValueByPath = (option, prop) => {\n  if (prop in option) {\n    return option[prop];\n  }\n\n  prop = prop.replace(/^\\./, \"\");\n  return getNestedValue(option, prop.split(\".\"));\n};\n\nconst getValueByKey = (option, prop) => {\n  if (!option || typeof option !== \"object\" || Array.isArray(option)) {\n    return void 0;\n  }\n\n  if (!prop) {\n    return option;\n  }\n\n  if (typeof prop === \"string\") {\n    return getValueByPath(option, prop);\n  }\n\n  if (typeof prop === \"function\") {\n    return prop(option);\n  }\n\n  return option;\n};\n\nexport { getValueByKey as a, getValueByPath as g };","map":{"version":3,"mappings":";;AAUa,uBAAiB,CAACA,MAAD,EAA8BC,UAA9B,KAA4D;EACpF,eAAWC,MAAX,KAAsB,CAAtB,EAAyB;IAAS;EAAO;;EAEvC,mBAAaF,OAAOC,WAAW,CAAX,CAAP,CAAb;;EACF,KAACE,WAASC,UAATD,CAAD,EAAuB;IACrB,eAAWD,MAAX,KAAsB,CAAtB,EAAyB;MACpB;IACT;;IACO;EACT;;EACA,OAAOG,eAAeD,UAAf,EAA2BH,WAAWK,KAAX,CAAiB,CAAjB,CAA3B,CAAP;AACF,CAXa;;AAmBA,uBAAiB,CAE5BN,MAF4B,EAEjBO,IAFiB,KAE6B;EACzD,IAAIA,QAAQP,MAAZ,EAAoB;IAClB,OAAQA,OAAQO,IAAR,CAAR;EACF;;EACOA,YAAKC,OAAL,CAAa,KAAb,EAAoB,EAApB;EACP,OAAOH,eAAeL,MAAf,EAAuBO,KAAKE,KAAL,CAAW,GAAX,CAAvB,CAAP;AACF,CARa;;AAgBA,sBAAgB,CAGzBT,MAHyB,EAIzBO,IAJyB,KAKtB;EACD,KAACP,MAAD,IAAW,OAAOA,MAAP,KAAkB,QAA7B,IAAyCU,MAAMC,OAAN,CAAcX,MAAd,CAAzC,EAAgE;IAAS;EAAU;;EAEvF,IAAI,CAACO,IAAL,EAAW;IAAS;EAAO;;EACvB,WAAOA,IAAP,KAAgB,QAAhB,EAA0B;IAAS,sBAAeP,MAAf,EAAuBO,IAAvB;EAA6B;;EAChE,WAAOA,IAAP,KAAgB,UAAhB,EAA4B;IAAE,OAAOA,KAAKP,MAAL,CAAP;EAAoB;;EAG/C;AACT,CAda","names":["option","propsArray","length","isObject","nestedItem","getNestedValue","slice","prop","replace","split","Array","isArray"],"sources":["../../../../src/utils/value-by-key.ts"],"sourcesContent":["import isObject from 'lodash/isObject.js'\n\ntype GetTypeByPath<T extends Record<string, any>, K extends string> =\nK extends keyof T\n    ? T[K]\n    : K extends `${infer TKey}.${infer Rest}`\n        ? GetTypeByPath<T[TKey], Rest>\n        : undefined\n\n// Find value in the object with an array of keys\nexport const getNestedValue = (option: Record<string, any>, propsArray: string[]): any => {\n  if (propsArray.length === 0) { return option }\n\n  const nestedItem = option[propsArray[0]]\n  if (!isObject(nestedItem)) {\n    if (propsArray.length === 1) {\n      return nestedItem\n    }\n    return undefined\n  }\n  return getNestedValue(nestedItem, propsArray.slice(1))\n}\n\n/**\n * Finds value in the object using string with dots 'key.key.key'\n *\n * @param option\n * @param prop\n */\nexport const getValueByPath = <\n  Key extends string, T extends Record<string | Key, unknown>\n>(option: T, prop: string | Key): GetTypeByPath<T, Key> => {\n  if (prop in option) {\n    return (option)[prop] as GetTypeByPath<T, Key>\n  }\n  prop = prop.replace(/^\\./, '') // remove first point symbol\n  return getNestedValue(option, prop.split('.'))\n}\n\n/**\n * Finds value of nested property inside an object.\n *\n * @param option - Object to look properties inside.\n * @param prop - String or function used to find nested property.\n */\nexport const getValueByKey = <\n  Option extends Record<string, unknown>, R\n>(\n    option: Option | string | number | ((...args: any[]) => any),\n    prop: string | ((option: Option) => R),\n  ) => {\n  if (!option || typeof option !== 'object' || Array.isArray(option)) { return undefined }\n\n  if (!prop) { return option }\n  if (typeof prop === 'string') { return getValueByPath(option, prop) }\n  if (typeof prop === 'function') { return prop(option) }\n\n  // if `prop` has different to string or function type and can't be processed\n  return option\n}\n"]},"metadata":{},"sourceType":"module"}
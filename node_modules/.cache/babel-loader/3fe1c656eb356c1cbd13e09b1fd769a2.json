{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { computed, toRefs, provide } from \"vue\";\nimport { u as useColors } from \"../../../composables/useColors.js\";\nimport { b as useStateful } from \"../../../composables/useStateful.js\";\nimport { b as useTreeHelpers } from \"./useTreeHelpers.js\";\nimport { T as TreeViewKey } from \"../types.js\";\n\nconst useTreeView = (props, emit) => {\n  const {\n    getColor\n  } = useColors();\n  const colorComputed = computed(() => getColor(props.color));\n  const isLeafSelectionComputed = computed(() => props.selectionType === \"leaf\");\n  const {\n    getText,\n    getValue,\n    getChecked,\n    getTrackBy,\n    getDisabled,\n    getExpanded,\n    iterateNodes,\n    getNodeProperty\n  } = useTreeHelpers(props);\n  const {\n    nodes,\n    expandAll,\n    filter,\n    filterMethod,\n    textBy\n  } = toRefs(props);\n  const {\n    valueComputed: expandedList\n  } = useStateful(props, emit, \"expanded\");\n  const {\n    valueComputed: checkedList\n  } = useStateful(props, emit, \"checked\");\n\n  const updateModel = (model, values, state) => {\n    if (state) {\n      model.value = model.value.concat(values).filter((value, idx, self) => self.indexOf(value) === idx);\n    } else {\n      model.value = model.value.filter(v => !values.includes(v));\n    }\n  };\n\n  const toggleCheckbox = (node, state) => {\n    let stateValue = state === null ? true : state;\n\n    if (state && node.indeterminate) {\n      stateValue = false;\n    }\n\n    const values = [getValue(node)];\n\n    if (isLeafSelectionComputed.value && node.hasChildren) {\n      const toggleChildren = nodes2 => {\n        nodes2.forEach(node2 => {\n          var _a;\n\n          if (node2.disabled) {\n            return;\n          }\n\n          if ((_a = node2.children) == null ? void 0 : _a.length) {\n            toggleChildren(node2.children);\n          }\n\n          values.push(getValue(node2));\n        });\n      };\n\n      toggleChildren(node.children);\n    }\n\n    updateModel(checkedList, values, stateValue);\n  };\n\n  const toggleNode = node => {\n    if (node.hasChildren) {\n      updateModel(expandedList, [getValue(node)], !node.expanded);\n    }\n  };\n\n  const createNode = ({\n    node,\n    level,\n    children = [],\n    computedFilterMethod: computedFilterMethod2\n  }) => {\n    var _a;\n\n    const valueBy = getValue(node);\n    let matchesFilter = true;\n    const hasChildren = !!children.length;\n    const disabled = getDisabled(node) || false;\n    let indeterminate = false;\n    let checked = checkedList.value.includes(valueBy) || false;\n\n    if (isLeafSelectionComputed.value && hasChildren) {\n      const isAllChildrenChecked = children.every(c => c.checked);\n      checked = isAllChildrenChecked;\n      indeterminate = !isAllChildrenChecked && children.some(c => c.indeterminate || c.checked);\n\n      if (indeterminate) {\n        checked = null;\n      }\n    }\n\n    if (filter.value) {\n      matchesFilter = (children == null ? void 0 : children.some(c => c.matchesFilter)) || ((_a = computedFilterMethod2.value) == null ? void 0 : _a.call(computedFilterMethod2, node, filter.value, textBy.value));\n    }\n\n    return { ...node,\n      level,\n      checked,\n      children,\n      disabled,\n      expanded: expandedList.value.includes(valueBy) || false,\n      hasChildren,\n      matchesFilter,\n      indeterminate\n    };\n  };\n\n  const computedFilterMethod = computed(() => {\n    if (filterMethod == null ? void 0 : filterMethod.value) {\n      return filterMethod.value;\n    }\n\n    return (node, filter2) => getText(node).toLowerCase().includes(filter2.toLowerCase());\n  });\n\n  const buildTree = (nodes2, level = 0) => nodes2.map(node => {\n    var _a;\n\n    if ((_a = node.children) == null ? void 0 : _a.length) {\n      const children = buildTree(node.children, level + 1);\n      return createNode({\n        node,\n        level,\n        children,\n        computedFilterMethod\n      });\n    }\n\n    return createNode({\n      node,\n      level,\n      computedFilterMethod,\n      children: []\n    });\n  });\n\n  const getFilteredNodes = nodes2 => nodes2.slice().filter(node => {\n    if (node.hasChildren) {\n      getFilteredNodes(node.children.slice());\n    }\n\n    return node.matchesFilter ? node : false;\n  });\n\n  provide(TreeViewKey, {\n    colorComputed,\n    iconBy: props.iconBy,\n    selectable: props.selectable,\n    getText,\n    getTrackBy,\n    toggleNode,\n    toggleCheckbox,\n    getNodeProperty\n  });\n  const treeItems = computed(() => buildTree(nodes.value));\n\n  const checkForInitialValues = () => {\n    const expandedValues = [];\n    const checkedValues = [];\n    iterateNodes(nodes.value, node => {\n      if (expandAll.value) {\n        expandedValues.push(getValue(node));\n      } else {\n        getExpanded(node) && expandedValues.push(getValue(node));\n      }\n\n      if (getChecked(node)) {\n        checkedValues.push(getValue(node));\n      }\n    });\n\n    if (expandedValues.length) {\n      updateModel(expandedList, expandedValues, true);\n    }\n\n    if (checkedValues.length) {\n      updateModel(checkedList, checkedValues, true);\n    }\n  };\n\n  checkForInitialValues();\n  return {\n    treeItems: computed(() => getFilteredNodes(treeItems.value)),\n    getText,\n    getTrackBy,\n    toggleCheckbox\n  };\n};\n\nexport { useTreeView as u };","map":{"version":3,"mappings":"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","names":["props","emit","getColor","useColors","colorComputed","computed","color","isLeafSelectionComputed","selectionType","getText","getValue","getChecked","getTrackBy","getDisabled","getExpanded","iterateNodes","getNodeProperty","useTreeHelpers","nodes","expandAll","filter","filterMethod","textBy","toRefs","valueComputed","expandedList","useStateful","checkedList","updateModel","model","values","state","value","concat","idx","self","indexOf","v","includes","node","indeterminate","stateValue","hasChildren","nodes2","node2","disabled","children","length","toggleChildren","expanded","level","computedFilterMethod","computedFilterMethod2","matchesFilter","checked","valueBy","isAllChildrenChecked","every","c","some","filter2","toLowerCase","map","buildTree","createNode","slice","getFilteredNodes","provide","TreeViewKey","iconBy","selectable","toggleNode","toggleCheckbox","treeItems","checkForInitialValues","expandedValues","checkedValues","push"],"sources":["../../../../../../src/components/va-tree-view/hooks/useTreeView.ts"],"sourcesContent":["import {\n  toRefs,\n  provide,\n  computed,\n  ComputedRef,\n  ExtractPropTypes,\n  WritableComputedRef,\n} from 'vue'\n\nimport { useColors, useStateful } from '../../../composables'\n\nimport type { TreeNode, TreeViewFilterMethod } from '../types'\nimport { useTreeHelpers, useTreeViewProps } from './useTreeHelpers'\nimport { TreeViewKey } from '../types'\n\ntype CreateNodeProps = {\n  node: TreeNode\n  level: number\n  children: TreeNode[]\n  computedFilterMethod: ComputedRef<TreeViewFilterMethod>\n}\n\ntype CreateNodeFunc = (props: CreateNodeProps) => TreeNode\ntype TreeViewEmitsFunc = (event: string, newValues: unknown) => void\ntype TreeBuilderFunc = (nodes: TreeNode[], level?: number) => TreeNode[]\ntype TypeModelValue = (string | number | TreeNode)[]\n\ntype UseTreeViewFunc = (props: ExtractPropTypes<typeof useTreeViewProps>, emit: TreeViewEmitsFunc) => {\n  treeItems: ComputedRef<TreeNode[]>\n  getText: (node: TreeNode) => string | number\n  getTrackBy: (node: TreeNode) => string | number\n  toggleCheckbox: (node: TreeNode, state: boolean) => void\n}\n\nconst useTreeView: UseTreeViewFunc = (props, emit) => {\n  const { getColor } = useColors()\n  const colorComputed = computed(() => getColor(props.color))\n  const isLeafSelectionComputed = computed(() => props.selectionType === 'leaf')\n  const {\n    getText,\n    getValue,\n    getChecked,\n    getTrackBy,\n    getDisabled,\n    getExpanded,\n    iterateNodes,\n    getNodeProperty,\n  } = useTreeHelpers(props)\n  const { nodes, expandAll, filter, filterMethod, textBy } = toRefs(props)\n  const { valueComputed: expandedList } = useStateful(props, emit, 'expanded')\n  const { valueComputed: checkedList } = useStateful(props, emit, 'checked')\n\n  const updateModel = (model: WritableComputedRef<TypeModelValue>, values: TypeModelValue, state: boolean) => {\n    if (state) {\n      model.value = model.value.concat(values)\n        .filter((value, idx, self) => self.indexOf(value) === idx)\n    } else {\n      model.value = model.value.filter(v => !values.includes(v))\n    }\n  }\n\n  const toggleCheckbox = (node: TreeNode, state: boolean | null) => {\n    let stateValue = state === null ? true : state\n\n    if (state && node.indeterminate) {\n      stateValue = false\n    }\n\n    const values = [getValue(node)]\n\n    if (isLeafSelectionComputed.value && node.hasChildren) {\n      const toggleChildren = (nodes: TreeNode[]) => {\n        nodes.forEach((node: TreeNode) => {\n          if (node.disabled) { return }\n\n          if (node.children?.length) { toggleChildren(node.children) }\n\n          values.push(getValue(node))\n        })\n      }\n\n      toggleChildren(node.children)\n    }\n\n    updateModel(checkedList, values, stateValue)\n  }\n\n  const toggleNode = (node: TreeNode): void => {\n    if (node.hasChildren) {\n      updateModel(expandedList, [getValue(node)], !node.expanded)\n    }\n  }\n\n  const createNode: CreateNodeFunc = ({ node, level, children = [], computedFilterMethod }) => {\n    const valueBy = getValue(node)\n    let matchesFilter = true\n    const hasChildren = !!children.length\n    const disabled = getDisabled(node) || false\n    let indeterminate = false\n    let checked: boolean | null = checkedList.value.includes(valueBy) || false\n\n    if (isLeafSelectionComputed.value && hasChildren) {\n      const isAllChildrenChecked = children.every(c => c.checked)\n\n      checked = isAllChildrenChecked\n      indeterminate = !isAllChildrenChecked && children.some(c => c.indeterminate || c.checked)\n\n      if (indeterminate) { checked = null }\n    }\n\n    if (filter.value) {\n      matchesFilter = children?.some(c => c.matchesFilter) || computedFilterMethod.value?.(node, filter.value, textBy.value)\n    }\n\n    return {\n      ...node,\n      level,\n      checked,\n      children,\n      disabled,\n      expanded: expandedList.value.includes(valueBy) || false,\n      hasChildren,\n      matchesFilter,\n      indeterminate,\n    }\n  }\n\n  const computedFilterMethod = computed<TreeViewFilterMethod>(() => {\n    if (filterMethod?.value) { return filterMethod.value }\n\n    return (node, filter) => getText(node).toLowerCase().includes(filter.toLowerCase())\n  })\n\n  const buildTree: TreeBuilderFunc = (nodes: TreeNode[], level = 0) => nodes.map((node: TreeNode) => {\n    if (node.children?.length) {\n      const children = buildTree(node.children, level + 1)\n\n      return createNode({ node, level, children, computedFilterMethod })\n    }\n\n    return createNode({ node, level, computedFilterMethod, children: [] })\n  })\n\n  const getFilteredNodes = (nodes: TreeNode[]): TreeNode[] => nodes.slice().filter((node) => {\n    if (node.hasChildren) { getFilteredNodes(node.children.slice()) }\n\n    return node.matchesFilter ? node : false\n  })\n\n  provide(TreeViewKey, {\n    colorComputed,\n    iconBy: props.iconBy,\n    selectable: props.selectable,\n    getText,\n    getTrackBy,\n    toggleNode,\n    toggleCheckbox,\n    getNodeProperty,\n  })\n\n  const treeItems = computed(() => buildTree(nodes.value))\n\n  const checkForInitialValues = () => {\n    const expandedValues: TypeModelValue = []\n    const checkedValues: TypeModelValue = []\n\n    iterateNodes(nodes.value, (node) => {\n      if (expandAll.value) {\n        expandedValues.push(getValue(node))\n      } else {\n        getExpanded(node) && expandedValues.push(getValue(node))\n      }\n\n      if (getChecked(node)) {\n        checkedValues.push(getValue(node))\n      }\n    })\n\n    if (expandedValues.length) {\n      updateModel(expandedList, expandedValues, true)\n    }\n\n    if (checkedValues.length) {\n      updateModel(checkedList, checkedValues, true)\n    }\n  }\n\n  checkForInitialValues()\n\n  return {\n    treeItems: computed(() => getFilteredNodes(treeItems.value)),\n    getText,\n    getTrackBy,\n    toggleCheckbox,\n  }\n}\n\nexport default useTreeView\n"]},"metadata":{},"sourceType":"module"}
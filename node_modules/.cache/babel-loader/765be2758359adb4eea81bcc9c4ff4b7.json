{"ast":null,"code":"import { t as throttle_1 } from \"../../../vendor.js\";\n\nfunction getWindowHeight() {\n  return document.documentElement.clientHeight || window.innerHeight || document.body.clientHeight;\n}\n\nfunction computeAffixedState({\n  coordinates,\n  offsetTop,\n  offsetBottom,\n  target\n}) {\n  let isTopAffixed = false;\n  let isBottomAffixed = false;\n  const windowHeight = getWindowHeight();\n\n  if (offsetTop != null && windowHeight) {\n    if (target === window) {\n      isTopAffixed = coordinates.top <= offsetTop;\n    } else {\n      const {\n        top\n      } = target.getBoundingClientRect();\n      isTopAffixed = coordinates.top - top <= offsetTop;\n    }\n  }\n\n  if (offsetBottom != null && windowHeight) {\n    if (target === window) {\n      isBottomAffixed = coordinates.bottom >= windowHeight - offsetBottom;\n    } else {\n      const {\n        bottom\n      } = target.getBoundingClientRect();\n      isBottomAffixed = bottom - coordinates.bottom <= offsetBottom;\n    }\n  }\n\n  return {\n    isTopAffixed,\n    isBottomAffixed\n  };\n}\n\nfunction checkAffixedStateChange(currentState, nextState) {\n  return currentState.isTopAffixed !== nextState.isTopAffixed || currentState.isBottomAffixed !== nextState.isBottomAffixed;\n}\n\nfunction handleThrottledEvent(eventName, context) {\n  const {\n    target,\n    element,\n    offsetTop,\n    offsetBottom,\n    setState,\n    getState,\n    initialPosition\n  } = context;\n\n  if (!element) {\n    return;\n  }\n\n  const isInitialCall = !eventName;\n  const coordinates = element.getBoundingClientRect();\n  const options = {\n    offsetBottom,\n    offsetTop,\n    target\n  };\n  const nextState = isInitialCall && initialPosition ? computeAffixedState({\n    coordinates: initialPosition,\n    ...options\n  }) : computeAffixedState({\n    coordinates,\n    ...options\n  });\n  const prevState = getState();\n\n  if (checkAffixedStateChange(prevState, nextState)) {\n    setState({ ...nextState,\n      width: coordinates.width\n    });\n  } else if (prevState.width !== coordinates.width) {\n    setState({ ...prevState,\n      width: coordinates.width\n    });\n  }\n}\n\nfunction useCaptureDefault(eventName) {\n  return eventName === \"scroll\";\n}\n\nfunction useEventsHandlerWithThrottle(events, {\n  handler,\n  useCapture = useCaptureDefault,\n  wait = 50\n}) {\n  const clearHandlersArray = events.map(eventName => {\n    const _handler = throttle_1(event => handler(eventName, event), wait);\n\n    window.addEventListener(eventName, _handler, useCapture(eventName));\n    return () => window.removeEventListener(eventName, _handler, useCapture(eventName));\n  });\n  return () => clearHandlersArray.forEach(clear => clear());\n}\n\nexport { getWindowHeight as g, handleThrottledEvent as h, useEventsHandlerWithThrottle as u };","map":{"version":3,"mappings":"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","names":["document","documentElement","clientHeight","window","innerHeight","body","coordinates","offsetTop","offsetBottom","target","isTopAffixed","isBottomAffixed","windowHeight","getWindowHeight","top","getBoundingClientRect","bottom","currentState","nextState","eventName","context","element","setState","getState","initialPosition","isInitialCall","options","computeAffixedState","prevState","width","events","handler","useCapture","useCaptureDefault","wait","map","throttle","event","addEventListener","_handler","removeEventListener","clearHandlersArray","forEach","clear"],"sources":["../../../../../src/components/va-affix/VaAffix-utils.ts"],"sourcesContent":["import throttle from 'lodash/throttle.js'\n\nexport type State = {\n  isTopAffixed: boolean;\n  isBottomAffixed: boolean;\n  width?: number;\n}\n\ntype Coordinates = {\n  top: number;\n  bottom: number;\n}\n\ntype ValuesToComputeAffixedState = {\n  coordinates: Coordinates;\n  offsetTop?: number;\n  offsetBottom?: number;\n  target: HTMLElement | Window | undefined;\n}\n\nexport function getWindowHeight () {\n  return document.documentElement.clientHeight ||\n    window.innerHeight ||\n    document.body.clientHeight\n}\n\nexport function computeAffixedState ({\n  coordinates,\n  offsetTop,\n  offsetBottom,\n  target,\n}: ValuesToComputeAffixedState): State {\n  let isTopAffixed = false\n  let isBottomAffixed = false\n\n  const windowHeight = getWindowHeight()\n\n  if (offsetTop != null && windowHeight) {\n    if (target === window) {\n      isTopAffixed = coordinates.top <= offsetTop\n    } else {\n      const { top } = (target as HTMLElement).getBoundingClientRect()\n      isTopAffixed = coordinates.top - top <= offsetTop\n    }\n  }\n\n  if (offsetBottom != null && windowHeight) {\n    if (target === window) {\n      isBottomAffixed = coordinates.bottom >= windowHeight - offsetBottom\n    } else {\n      const { bottom } = (target as HTMLElement).getBoundingClientRect()\n      isBottomAffixed = bottom - coordinates.bottom <= offsetBottom\n    }\n  }\n\n  return {\n    isTopAffixed,\n    isBottomAffixed,\n  }\n}\n\nfunction checkAffixedStateChange (currentState: State, nextState: State): boolean {\n  return currentState.isTopAffixed !== nextState.isTopAffixed ||\n    currentState.isBottomAffixed !== nextState.isBottomAffixed\n}\n\nexport type Context = {\n  offsetTop?: number;\n  offsetBottom?: number;\n  element: HTMLElement | undefined;\n  target: HTMLElement | Window | undefined;\n  setState: (state: State) => void;\n  getState: () => State;\n  initialPosition?: DOMRect | undefined;\n}\n\nexport function handleThrottledEvent (eventName: string | null, context: Context) {\n  const { target, element, offsetTop, offsetBottom, setState, getState, initialPosition } = context\n\n  if (!element) { return }\n\n  const isInitialCall = !eventName\n  const coordinates = element.getBoundingClientRect()\n  const options = {\n    offsetBottom,\n    offsetTop,\n    target,\n  }\n\n  const nextState = isInitialCall && initialPosition\n    ? computeAffixedState({ coordinates: initialPosition, ...options })\n    : computeAffixedState({ coordinates, ...options })\n\n  const prevState = getState()\n\n  if (checkAffixedStateChange(prevState, nextState)) {\n    setState({ ...nextState, width: coordinates.width })\n  } else if (prevState.width !== coordinates.width) {\n    setState({ ...prevState, width: coordinates.width })\n  }\n}\n\nfunction useCaptureDefault (eventName: string) {\n  // This event type must bubble to the Window object only when dispatched on the Document element\n  // https://www.w3.org/TR/2014/WD-DOM-Level-3-Events-20140925/#event-type-scroll\n  return eventName === 'scroll'\n}\n\ntype Options = {\n  handler: (eventName: string, event: Event) => void;\n  useCapture?: (eventName: string) => boolean;\n  wait?: number;\n}\n\nexport function useEventsHandlerWithThrottle (events: string[], {\n  handler,\n  useCapture = useCaptureDefault,\n  wait = 50,\n}: Options) {\n  const clearHandlersArray = events.map(eventName => {\n    const _handler = throttle((event: Event) => handler(eventName, event), wait)\n\n    window.addEventListener(eventName, _handler, useCapture(eventName))\n\n    return () => window.removeEventListener(eventName, _handler, useCapture(eventName))\n  })\n\n  return () => clearHandlersArray.forEach(clear => clear())\n}\n"]},"metadata":{},"sourceType":"module"}
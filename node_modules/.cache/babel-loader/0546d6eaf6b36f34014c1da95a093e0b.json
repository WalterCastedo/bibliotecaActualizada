{"ast":null,"code":"import { ref, onMounted, onBeforeUnmount, watch, computed } from \"vue\";\nimport Cleave from \"cleave.js\";\nconst DEFAULT_MASK_TOKENS = {\n  creditCard: {\n    creditCard: true\n  },\n  date: {\n    date: true,\n    datePattern: [\"d\", \"m\", \"Y\"]\n  },\n  time: {\n    time: true,\n    timePattern: [\"h\", \"m\"],\n    timeFormat: \"24\"\n  },\n  numeral: {\n    numeral: true,\n    numeralThousandsGroupStyle: \"thousand\"\n  }\n};\nconst useCleaveProps = {\n  mask: {\n    type: [String, Object],\n    default: \"\"\n  },\n  returnRaw: {\n    type: Boolean,\n    default: true\n  },\n  modelValue: {\n    type: [String, Number],\n    default: \"\"\n  }\n};\n\nconst useCleave = (element, props, emit) => {\n  const cleave = ref();\n\n  const getMask = mask => {\n    if (typeof mask === \"string\") {\n      return DEFAULT_MASK_TOKENS[mask] ? { ...DEFAULT_MASK_TOKENS[mask]\n      } : {};\n    }\n\n    return { ...mask\n    };\n  };\n\n  const destroyCleave = () => {\n    if (cleave.value) {\n      cleave.value.destroy();\n    }\n  };\n\n  const initCleave = () => {\n    destroyCleave();\n\n    if (!element.value) {\n      return;\n    }\n\n    cleave.value = new Cleave(element.value, getMask(props.mask));\n  };\n\n  onMounted(() => {\n    initCleave();\n  });\n  onBeforeUnmount(() => {\n    destroyCleave();\n  });\n  watch(() => [element.value, props.mask], () => {\n    initCleave();\n  });\n  const computedValue = computed(() => {\n    if (cleave.value) {\n      if (props.returnRaw && props.modelValue === cleave.value.getRawValue()) {\n        return cleave.value.getFormattedValue();\n      }\n    }\n\n    return props.modelValue;\n  });\n\n  const onInput = event => {\n    const value = event.target.value;\n\n    if (props.mask !== \"string\" && !Object.keys(props.mask).length) {\n      emit(\"update:modelValue\", value);\n      return;\n    }\n\n    if (cleave.value) {\n      cleave.value.setRawValue(value);\n\n      if (props.returnRaw) {\n        emit(\"update:modelValue\", cleave.value.getRawValue());\n        return;\n      }\n\n      emit(\"update:modelValue\", cleave.value.getFormattedValue());\n      return;\n    }\n\n    emit(\"update:modelValue\", value);\n  };\n\n  return {\n    cleave,\n    computedValue,\n    onInput\n  };\n};\n\nexport { useCleave as a, useCleaveProps as u };","map":{"version":3,"mappings":";;AAIA,MAAMA,sBAA+D;EACnEC,YAAY;IACVA,YAAY;EADF,CADuD;EAInEC,MAAM;IACJA,MAAM,IADF;IAEJC,aAAa,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX;EAFT,CAJ6D;EAQnEC,MAAM;IACJA,MAAM,IADF;IAEJC,aAAa,CAAC,GAAD,EAAM,GAAN,CAFT;IAGJC,YAAY;EAHR,CAR6D;EAanEC,SAAS;IACPA,SAAS,IADF;IAEPC,4BAA4B;EAFrB;AAb0D,CAArE;AAmBO,MAAMC,iBAAiB;EAC5BC,MAAM;IAAEC,MAAM,CAACC,MAAD,EAASC,MAAT,CAAR;IAAyEC,SAAS;EAAlF,CADsB;EAE5BC,WAAW;IAAEJ,MAAMK,OAAR;IAAiBF,SAAS;EAA1B,CAFiB;EAG5BG,YAAY;IAAEN,MAAM,CAACC,MAAD,EAASM,MAAT,CAAR;IAA0BJ,SAAS;EAAnC;AAHgB,CAAvB;;AAMA,MAAMK,YAAY,CACvBC,OADuB,EAEvBC,KAFuB,EAGvBC,IAHuB,KAIpB;EACH,MAAMC,SAASC,KAAf;;EAEM,gBAAWd,IAAD,IAAkC;IAC5C,WAAOA,IAAP,KAAgB,QAAhB,EAA0B;MAC5B,OAAOV,oBAAoBU,IAApB,IAA4B,EAAE,GAAGV,oBAAoBU,IAApB;MAAL,CAA5B,GAA+D,EAAtE;IACF;;IACO,SAAE,GAAGA;IAAL;EAAU,CAJb;;EAON,MAAMe,gBAAgB,MAAM;IAC1B,IAAIF,OAAOG,KAAX,EAAkB;MAAEH,OAAOG,KAAP,CAAaC,OAAb;IAAuB;EAAA,CAD7C;;EAIA,MAAMC,aAAa,MAAM;IACTH;;IAEV,KAACL,QAAQM,KAAT,EAAgB;MAAE;IAAO;;IAEtBH,eAAQ,IAAIM,MAAJ,CAAWT,QAAQM,KAAnB,EAA0BI,QAAQT,MAAMX,IAAd,CAA1B,CAAR;EAAqD,CAL9D;;EAQAqB,UAAU,MAAM;IAAaH;EAAG,CAAhC;EACAI,gBAAgB,MAAM;IAAgBP;EAAG,CAAzC;EAEAQ,MAAM,MAAM,CAACb,QAAQM,KAAT,EAAgBL,MAAMX,IAAtB,CAAZ,EAAyC,MAAM;IAAakB;EAAG,CAA/D;EAEM,sBAAgBM,SAA0B,MAAM;IACpD,IAAIX,OAAOG,KAAX,EAAkB;MAChB,IAAIL,MAAMN,SAAN,IAAmBM,MAAMJ,UAAN,KAAqBM,OAAOG,KAAP,CAAaS,WAAb,EAA5C,EAAwE;QAC/D,cAAOT,KAAP,CAAaU,iBAAb;MACT;IACF;;IAEA,OAAOf,MAAMJ,UAAb;EACD,CARqB,CAAhB;;EAUA,gBAAWoB,KAAD,IAAkB;IAC1B,cAASA,MAAMC,MAAN,CAAkCZ,KAA3C;;IAEF,UAAMhB,IAAN,KAAe,QAAf,IAA2B,CAACG,OAAO0B,IAAP,CAAYlB,MAAMX,IAAlB,EAAwB8B,MAApD,EAA4D;MAC9DlB,KAAK,mBAAL,EAA0BI,KAA1B;MACA;IACF;;IAEA,IAAIH,OAAOG,KAAX,EAAkB;MACTH,aAAMkB,WAAN,CAAkBf,KAAlB;;MACP,IAAIL,MAAMN,SAAV,EAAqB;QACnBO,KAAK,mBAAL,EAA0BC,OAAOG,KAAP,CAAaS,WAAb,EAA1B;QACA;MACF;;MAEAb,KAAK,mBAAL,EAA0BC,OAAOG,KAAP,CAAaU,iBAAb,EAA1B;MACA;IACF;;IAEAd,KAAK,mBAAL,EAA0BI,KAA1B;EAA+B,CAnB3B;;EAsBC;IACLH,MADK;IAELmB,aAFK;IAGLC;EAHK;AAKT,CApEO","names":["DEFAULT_MASK_TOKENS","creditCard","date","datePattern","time","timePattern","timeFormat","numeral","numeralThousandsGroupStyle","useCleaveProps","mask","type","String","Object","default","returnRaw","Boolean","modelValue","Number","useCleave","element","props","emit","cleave","ref","destroyCleave","value","destroy","initCleave","Cleave","getMask","onMounted","onBeforeUnmount","watch","computed","getRawValue","getFormattedValue","event","target","keys","length","setRawValue","computedValue","onInput"],"sources":["../../../../../../src/components/va-input/hooks/useCleave.ts"],"sourcesContent":["import { computed, onBeforeUnmount, onMounted, PropType, ref, Ref, watch, ExtractPropTypes } from 'vue'\nimport Cleave from 'cleave.js'\nimport { CleaveOptions } from 'cleave.js/options'\n\nconst DEFAULT_MASK_TOKENS: Record<string, Record<string, unknown>> = {\n  creditCard: {\n    creditCard: true,\n  },\n  date: {\n    date: true,\n    datePattern: ['d', 'm', 'Y'],\n  },\n  time: {\n    time: true,\n    timePattern: ['h', 'm'],\n    timeFormat: '24',\n  },\n  numeral: {\n    numeral: true,\n    numeralThousandsGroupStyle: 'thousand',\n  },\n}\n\nexport const useCleaveProps = {\n  mask: { type: [String, Object] as PropType<string | Record<string, number[]>>, default: '' },\n  returnRaw: { type: Boolean, default: true },\n  modelValue: { type: [String, Number], default: '' },\n}\n\nexport const useCleave = (\n  element: Ref<HTMLInputElement | undefined>,\n  props: ExtractPropTypes<typeof useCleaveProps>,\n  emit: (event: 'update:modelValue' | any, ...args: any[]) => any,\n) => {\n  const cleave = ref<Cleave>()\n\n  const getMask = (mask: CleaveOptions | string) => {\n    if (typeof mask === 'string') {\n      return DEFAULT_MASK_TOKENS[mask] ? { ...DEFAULT_MASK_TOKENS[mask] } : {}\n    }\n    return { ...mask }\n  }\n\n  const destroyCleave = () => {\n    if (cleave.value) { cleave.value.destroy() }\n  }\n\n  const initCleave = () => {\n    destroyCleave()\n\n    if (!element.value) { return }\n\n    cleave.value = new Cleave(element.value, getMask(props.mask))\n  }\n\n  onMounted(() => { initCleave() })\n  onBeforeUnmount(() => { destroyCleave() })\n\n  watch(() => [element.value, props.mask], () => { initCleave() })\n\n  const computedValue = computed<string | number>(() => {\n    if (cleave.value) {\n      if (props.returnRaw && props.modelValue === cleave.value.getRawValue()) {\n        return cleave.value.getFormattedValue()\n      }\n    }\n\n    return props.modelValue\n  })\n\n  const onInput = (event: Event) => {\n    const value = (event.target as HTMLInputElement).value\n\n    if (props.mask !== 'string' && !Object.keys(props.mask).length) {\n      emit('update:modelValue', value)\n      return\n    }\n\n    if (cleave.value) {\n      cleave.value.setRawValue(value)\n      if (props.returnRaw) {\n        emit('update:modelValue', cleave.value.getRawValue())\n        return\n      }\n\n      emit('update:modelValue', cleave.value.getFormattedValue())\n      return\n    }\n\n    emit('update:modelValue', value)\n  }\n\n  return {\n    cleave,\n    computedValue,\n    onInput,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { computed, unref, watchPostEffect } from \"vue\";\nimport { m as mapObject } from \"../utils/map-object.js\";\nimport { u as useDomRect } from \"./useDomRect.js\";\nimport { u as useDocument } from \"./useDocument.js\";\nconst placementsPositions = [\"top\", \"bottom\", \"left\", \"right\"].reduce((acc, position) => [...acc, position, `${position}-start`, `${position}-end`, `${position}-center`], [\"auto\"]);\n\nconst coordsToCss = ({\n  x,\n  y\n}) => ({\n  left: `${x}px`,\n  top: `${y}px`\n});\n\nconst parsePlacement = placement => {\n  let [position, align] = placement.split(\"-\");\n\n  if (position === \"auto\") {\n    position = \"bottom\";\n  }\n\n  return {\n    position,\n    align: align || \"center\"\n  };\n};\n\nconst parseOffset = offset => {\n  return Array.isArray(offset) ? {\n    main: offset[0],\n    cross: offset[1]\n  } : {\n    main: offset,\n    cross: 0\n  };\n};\n\nconst calculateContentAlignment = (align, anchorStart, anchorSize, contentSize) => {\n  if (align === \"start\") {\n    return anchorStart;\n  }\n\n  if (align === \"end\") {\n    return anchorStart + anchorSize - contentSize;\n  }\n\n  return anchorStart + (anchorSize - contentSize) / 2;\n};\n\nconst calculateContentCoords = (placement, anchor, content) => {\n  const {\n    position,\n    align\n  } = parsePlacement(placement);\n  const alignmentX = calculateContentAlignment(align, anchor.left, anchor.width, content.width);\n  const alignmentY = calculateContentAlignment(align, anchor.top, anchor.height, content.height);\n\n  switch (position) {\n    case \"top\":\n      return {\n        x: alignmentX,\n        y: anchor.top - content.height\n      };\n\n    case \"left\":\n      return {\n        y: alignmentY,\n        x: anchor.left - content.width\n      };\n\n    case \"right\":\n      return {\n        y: alignmentY,\n        x: anchor.right\n      };\n\n    case \"bottom\":\n    default:\n      return {\n        x: alignmentX,\n        y: anchor.bottom\n      };\n  }\n};\n\nconst calculateOffsetCoords = (placement, offset) => {\n  const {\n    position\n  } = parsePlacement(placement);\n  const {\n    main,\n    cross\n  } = parseOffset(offset);\n\n  switch (position) {\n    case \"left\":\n      return {\n        y: cross,\n        x: -main\n      };\n\n    case \"right\":\n      return {\n        y: cross,\n        x: main\n      };\n\n    case \"top\":\n      return {\n        y: -main,\n        x: cross\n      };\n\n    case \"bottom\":\n    default:\n      return {\n        y: main,\n        x: cross\n      };\n  }\n};\n\nconst calculateContentOverflow = (coords, content, viewport) => {\n  const xMax = viewport.right;\n  const yMax = viewport.bottom;\n  const xMin = viewport.left;\n  const yMin = viewport.top;\n  return {\n    top: Math.max(yMin - coords.y, 0),\n    bottom: Math.max(coords.y + content.height - yMax, 0),\n    left: Math.max(xMin - coords.x, 0),\n    right: Math.max(coords.x + content.width - xMax, 0)\n  };\n};\n\nconst clamp = (min, v, max) => Math.max(Math.min(v, max), min);\n\nconst calculateClipToEdge = (coords, offsetCoords, content, anchor, viewport) => {\n  const {\n    top,\n    bottom,\n    left,\n    right\n  } = calculateContentOverflow(coords, content, viewport);\n  const x = coords.x - right + left;\n  const y = coords.y - bottom + top;\n  const {\n    x: offsetX,\n    y: offsetY\n  } = offsetCoords;\n  return {\n    x: clamp(anchor.left + offsetX - content.width, x, anchor.right + offsetX),\n    y: clamp(anchor.top + offsetY - content.height, y, anchor.bottom + offsetY)\n  };\n};\n\nconst getAutoPlacement = (placement, coords, content, viewport) => {\n  const {\n    position\n  } = parsePlacement(placement);\n  const overflow = calculateContentOverflow(coords, content, viewport);\n  const newPlacements = {\n    top: \"bottom\",\n    bottom: \"top\",\n    right: \"left\",\n    left: \"right\"\n  };\n\n  if (!overflow[position]) {\n    return placement;\n  }\n\n  const newPlacement = newPlacements[position];\n\n  if (newPlacement === \"bottom\" || newPlacement === \"top\") {\n    if (overflow.left) {\n      return [newPlacement, \"start\"].join(\"-\");\n    }\n\n    if (overflow.right) {\n      return [newPlacement, \"end\"].join(\"-\");\n    }\n  }\n\n  if (newPlacement === \"left\" || newPlacement === \"right\") {\n    if (overflow.top) {\n      return [newPlacement, \"start\"].join(\"-\");\n    }\n\n    if (overflow.bottom) {\n      return [newPlacement, \"end\"].join(\"-\");\n    }\n  }\n\n  return newPlacement;\n};\n\nconst findFirstRelativeParent = el => {\n  while (el) {\n    const positionValue = window.getComputedStyle(el).getPropertyValue(\"position\") || el.style.position;\n\n    if (positionValue === \"relative\") {\n      return el;\n    }\n\n    el = el.parentElement;\n  }\n\n  return document.body;\n};\n\nconst useDropdown = (anchorRef, contentRef, options) => {\n  const documentRef = useDocument();\n  const rootRef = computed(() => {\n    if (!documentRef.value) {\n      return void 0;\n    }\n\n    const {\n      root\n    } = unref(options);\n\n    if (root) {\n      let el;\n\n      if (typeof root === \"string\") {\n        el = documentRef.value.querySelector(root);\n      } else {\n        el = root;\n      }\n\n      if (!el) {\n        return documentRef.value.body;\n      }\n\n      return findFirstRelativeParent(el);\n    }\n\n    return documentRef.value.body;\n  });\n  const {\n    domRect: anchorDomRect\n  } = useDomRect(anchorRef);\n  const {\n    domRect: contentDomRect\n  } = useDomRect(contentRef);\n  const css = {\n    width: \"max-content\",\n    position: \"absolute\"\n  };\n  watchPostEffect(() => {\n    var _a, _b;\n\n    if (!rootRef.value || !anchorDomRect.value || !contentDomRect.value) {\n      return;\n    }\n\n    const {\n      placement,\n      offset,\n      keepAnchorWidth,\n      autoPlacement,\n      stickToEdges\n    } = unref(options);\n    let coords = calculateContentCoords(placement, anchorDomRect.value, contentDomRect.value);\n    let offsetCoords = {\n      x: 0,\n      y: 0\n    };\n\n    if (offset) {\n      offsetCoords = calculateOffsetCoords(placement, offset);\n      coords = mapObject(coords, (c, key) => c + offsetCoords[key]);\n    }\n\n    const rootRect = rootRef.value.getBoundingClientRect();\n    const viewportRect = (_b = (_a = unref(options).viewport) == null ? void 0 : _a.getBoundingClientRect()) != null ? _b : rootRect;\n\n    if (autoPlacement) {\n      const newPlacement = getAutoPlacement(placement, coords, contentDomRect.value, viewportRect);\n\n      if (newPlacement !== placement) {\n        coords = calculateContentCoords(newPlacement, anchorDomRect.value, contentDomRect.value);\n\n        if (offset) {\n          offsetCoords = calculateOffsetCoords(newPlacement, offset);\n          coords = mapObject(coords, (c, key) => c + offsetCoords[key]);\n        }\n      }\n    }\n\n    if (stickToEdges) {\n      coords = calculateClipToEdge(coords, offsetCoords, contentDomRect.value, anchorDomRect.value, viewportRect);\n    }\n\n    coords.x -= rootRect.x;\n    coords.y -= rootRect.y;\n\n    if (contentRef.value) {\n      let widthCss = {};\n\n      if (keepAnchorWidth) {\n        const {\n          width\n        } = anchorDomRect.value;\n        widthCss = {\n          width: `${width}px`,\n          maxWidth: `${width}px`\n        };\n      }\n\n      Object.assign(contentRef.value.style, { ...css,\n        ...coordsToCss(coords),\n        ...widthCss\n      });\n    }\n  });\n  return {\n    anchorDomRect,\n    contentDomRect\n  };\n};\n\nexport { placementsPositions as p, useDropdown as u };","map":{"version":3,"mappings":"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","names":["reduce","acc","position","coordsToCss","x","y","left","top","parsePlacement","placement","align","split","parseOffset","offset","Array","isArray","main","cross","calculateContentAlignment","anchorStart","anchorSize","contentSize","calculateContentCoords","anchor","content","width","height","alignmentX","alignmentY","right","bottom","calculateOffsetCoords","calculateContentOverflow","coords","viewport","xMax","yMax","xMin","yMin","Math","max","clamp","min","v","calculateClipToEdge","offsetCoords","offsetX","offsetY","getAutoPlacement","overflow","newPlacements","newPlacement","join","findFirstRelativeParent","el","window","getComputedStyle","getPropertyValue","style","positionValue","parentElement","document","body","useDropdown","anchorRef","contentRef","options","documentRef","useDocument","computed","value","root","unref","querySelector","domRect","anchorDomRect","useDomRect","contentDomRect","css","watchPostEffect","rootRef","keepAnchorWidth","autoPlacement","stickToEdges","mapObject","c","key","getBoundingClientRect","viewportRect","rootRect","widthCss","maxWidth","Object"],"sources":["../../../../src/composables/useDropdown.ts"],"sourcesContent":["import { computed, Ref, unref, watchPostEffect } from 'vue'\n\nimport { mapObject } from '../utils/map-object'\nimport { useDomRect } from './useDomRect'\nimport { useDocument } from './useDocument'\n\nexport type PlacementPosition = 'top' | 'bottom' | 'left' | 'right'\nexport type PlacementAlignment = 'start' | 'end' | 'center'\nexport type Placement = PlacementPosition | 'auto' | `${PlacementPosition}-${PlacementAlignment}`\nexport type Offset = number | [number, number]\n\ntype Coords = { x: number, y: number }\ntype AlignCoords = { main: number, cross: number }\n\nexport const placementsPositions = ['top', 'bottom', 'left', 'right']\n  .reduce((acc, position) => [...acc, position, `${position}-start`, `${position}-end`, `${position}-center`], ['auto'] as string[])\n\nconst coordsToCss = ({ x, y }: Coords) => ({ left: `${x}px`, top: `${y}px` })\n\nconst parsePlacement = (placement: Placement) => {\n  let [position, align] = placement.split('-') as [PlacementPosition | 'auto', PlacementAlignment | undefined]\n  if (position === 'auto') {\n    position = 'bottom'\n  }\n\n  return { position, align: align || 'center' }\n}\n\nconst parseOffset = (offset: Offset): AlignCoords => {\n  return Array.isArray(offset) ? { main: offset[0], cross: offset[1] } : { main: offset, cross: 0 }\n}\n\nconst calculateContentAlignment = (align: PlacementAlignment, anchorStart: number, anchorSize: number, contentSize: number) => {\n  if (align === 'start') { return anchorStart }\n  if (align === 'end') { return anchorStart + anchorSize - contentSize }\n\n  return anchorStart + (anchorSize - contentSize) / 2\n}\n\nconst calculateContentCoords = (placement: Placement, anchor: DOMRect, content: DOMRect) => {\n  const { position, align } = parsePlacement(placement)\n\n  const alignmentX = calculateContentAlignment(align, anchor.left, anchor.width, content.width)\n  const alignmentY = calculateContentAlignment(align, anchor.top, anchor.height, content.height)\n\n  switch (position) {\n    case 'top': return { x: alignmentX, y: anchor.top - content.height }\n    case 'left': return { y: alignmentY, x: anchor.left - content.width }\n    case 'right': return { y: alignmentY, x: anchor.right }\n    case 'bottom':\n    default: return { x: alignmentX, y: anchor.bottom }\n  }\n}\n\nconst calculateOffsetCoords = (placement: Placement, offset: Offset): Coords => {\n  const { position } = parsePlacement(placement)\n  const { main, cross } = parseOffset(offset)\n\n  switch (position) {\n    case 'left': return { y: cross, x: -main }\n    case 'right': return { y: cross, x: main }\n    case 'top': return { y: -main, x: cross }\n    case 'bottom':\n    default: return { y: main, x: cross }\n  }\n}\n\n/** Returns how much content overflow */\nconst calculateContentOverflow = (coords: Coords, content: DOMRect, viewport: DOMRect) => {\n  const xMax = viewport.right\n  const yMax = viewport.bottom\n  const xMin = viewport.left\n  const yMin = viewport.top\n\n  return {\n    top: Math.max(yMin - coords.y, 0),\n    bottom: Math.max((coords.y + content.height) - yMax, 0),\n    left: Math.max(xMin - coords.x, 0),\n    right: Math.max((coords.x + content.width) - xMax, 0),\n  }\n}\n\nconst clamp = (min: number, v: number, max: number) => Math.max(Math.min(v, max), min)\n\nconst calculateClipToEdge = (coords: Coords, offsetCoords: Coords, content: DOMRect, anchor: DOMRect, viewport: DOMRect) => {\n  const { top, bottom, left, right } = calculateContentOverflow(coords, content, viewport)\n\n  // Add left overflow, sub right overflow so content always stick to edge\n  const x = coords.x - right + left\n  const y = coords.y - bottom + top\n\n  const { x: offsetX, y: offsetY } = offsetCoords\n\n  return {\n    // Clamp content position near anchor, so any content edge should touch anchor edge\n    x: clamp(anchor.left + offsetX - content.width, x, anchor.right + offsetX),\n    y: clamp(anchor.top + offsetY - content.height, y, anchor.bottom + offsetY),\n  }\n}\n\nconst getAutoPlacement = (placement: Placement, coords: Coords, content: DOMRect, viewport: DOMRect): Placement => {\n  const { position } = parsePlacement(placement)\n  const overflow = calculateContentOverflow(coords, content, viewport)\n\n  const newPlacements = {\n    top: 'bottom' as Placement,\n    bottom: 'top' as Placement,\n    right: 'left' as Placement,\n    left: 'right' as Placement,\n  }\n\n  if (!overflow[position]) { return placement }\n\n  // TODO: This is not recursive, if there is overflow in left and right - still will be a problem\n  // Might need to use some different algorithm here\n  const newPlacement = newPlacements[position]\n\n  if (newPlacement === 'bottom' || newPlacement === 'top') {\n    // cross: →\n    if (overflow.left) {\n      return [newPlacement, 'start'].join('-') as Placement\n    }\n    if (overflow.right) {\n      return [newPlacement, 'end'].join('-') as Placement\n    }\n  }\n\n  if (newPlacement === 'left' || newPlacement === 'right') {\n    // cross: ↓\n    if (overflow.top) {\n      return [newPlacement, 'start'].join('-') as Placement\n    }\n    if (overflow.bottom) {\n      return [newPlacement, 'end'].join('-') as Placement\n    }\n  }\n\n  return newPlacement\n}\n\nconst findFirstRelativeParent = (el: Element | null) => {\n  while (el) {\n    // TODO: Remove the el.style.position after fix of this issue: https://github.com/nuxt/framework/issues/3587\n    // TODO: Remove from the va-dropdown.vue the inline style (position: relative)\n    const positionValue = window.getComputedStyle(el).getPropertyValue('position') ||\n      (el as HTMLElement).style.position\n\n    if (positionValue === 'relative') { return el }\n\n    el = el.parentElement\n  }\n\n  return document.body\n}\n\nexport type usePopoverOptions = {\n  keepAnchorWidth?: boolean,\n  autoPlacement?: boolean,\n  stickToEdges?: boolean,\n  placement: Placement,\n  offset?: Offset,\n  /** Root element selector */\n  root?: string | HTMLElement,\n  viewport?: HTMLElement,\n}\n\n/**\n * Updates `contentRef` css, make it position fixed and moves relative to `anchorRef`\n * @param options make options reactive if you want popover to react on options change.\n */\nexport const useDropdown = (\n  anchorRef: Ref<HTMLElement | undefined>,\n  contentRef: Ref<HTMLElement | undefined>,\n  options: usePopoverOptions | Ref<usePopoverOptions>,\n) => {\n  const documentRef = useDocument()\n  const rootRef = computed(() => {\n    if (!documentRef.value) { return undefined }\n\n    const { root } = unref(options)\n\n    if (root) {\n      let el\n      if (typeof root === 'string') {\n        el = documentRef.value.querySelector(root)\n      } else {\n        el = root\n      }\n      if (!el) { return documentRef.value.body }\n      return findFirstRelativeParent(el)\n    }\n\n    return documentRef.value.body\n  })\n  const { domRect: anchorDomRect } = useDomRect(anchorRef)\n  const { domRect: contentDomRect } = useDomRect(contentRef)\n\n  const css = {\n    width: 'max-content',\n    position: 'absolute',\n  }\n\n  watchPostEffect(() => {\n    if (!rootRef.value || !anchorDomRect.value || !contentDomRect.value) { return }\n\n    const { placement, offset, keepAnchorWidth, autoPlacement, stickToEdges } = unref(options)\n\n    // calculate coords (x and y) of content left-top corner\n    let coords = calculateContentCoords(placement, anchorDomRect.value, contentDomRect.value)\n\n    let offsetCoords: Coords = { x: 0, y: 0 }\n    if (offset) {\n      offsetCoords = calculateOffsetCoords(placement, offset)\n      coords = mapObject(coords, (c, key) => c + offsetCoords[key])\n    }\n\n    const rootRect = rootRef.value.getBoundingClientRect()\n    const viewportRect = unref(options).viewport?.getBoundingClientRect() ?? rootRect\n\n    if (autoPlacement) {\n      const newPlacement = getAutoPlacement(placement, coords, contentDomRect.value, viewportRect)\n      if (newPlacement !== placement) {\n        coords = calculateContentCoords(newPlacement, anchorDomRect.value, contentDomRect.value)\n\n        if (offset) {\n          offsetCoords = calculateOffsetCoords(newPlacement, offset)\n          coords = mapObject(coords, (c, key) => c + offsetCoords[key])\n        }\n      }\n    }\n\n    if (stickToEdges) {\n      coords = calculateClipToEdge(coords, offsetCoords, contentDomRect.value, anchorDomRect.value, viewportRect)\n    }\n\n    coords.x -= rootRect.x\n    coords.y -= rootRect.y\n\n    if (contentRef.value) {\n      let widthCss = {}\n      if (keepAnchorWidth) {\n        const { width } = anchorDomRect.value\n        widthCss = { width: `${width}px`, maxWidth: `${width}px` }\n      }\n\n      Object.assign(contentRef.value.style, {\n        ...css,\n        ...coordsToCss(coords),\n        ...widthCss,\n      })\n    }\n  })\n\n  return {\n    anchorDomRect,\n    contentDomRect,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
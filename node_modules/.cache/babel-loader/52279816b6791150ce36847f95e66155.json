{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { shallowRef, computed, ref, getCurrentInstance, onMounted, watch } from \"vue\";\nimport { u as useEvent } from \"../../composables/useEvent.js\";\n\nconst isParsableMeasure = value => {\n  if (typeof value === \"string\") {\n    return !isNaN(+value) || value.endsWith(\"px\") || value.endsWith(\"rem\");\n  }\n\n  return false;\n};\n\nconst isParsablePositiveMeasure = value => {\n  if (typeof value === \"number\") {\n    return value >= 0;\n  }\n\n  return isParsableMeasure(value) && parseInt(value) >= 0;\n};\n\nconst validateSizeProp = (v, propName) => {\n  const isProperValue = isParsablePositiveMeasure(v);\n  return isProperValue;\n};\n\nconst useVirtualScrollerSizesProps = {\n  horizontal: {\n    type: Boolean,\n    default: false\n  },\n  itemSize: {\n    type: [Number, String],\n    default: 0,\n    validator: v => {\n      return validateSizeProp(v);\n    }\n  },\n  wrapperSize: {\n    type: [Number, String],\n    default: 100,\n    validator: v => {\n      return validateSizeProp(v);\n    }\n  }\n};\n\nconst useVirtualScrollerSizes = (props, scrollPosition) => {\n  const list = shallowRef();\n  const wrapper = shallowRef();\n\n  const parseSizeValue = value => {\n    if (typeof value === \"string\") {\n      const parsedValue = parseInt(value);\n\n      if (isNaN(parsedValue)) {\n        return 0;\n      }\n\n      return value.endsWith(\"rem\") ? parsedValue * pageFontSize.value : parsedValue;\n    }\n\n    return value;\n  };\n\n  const wrapperSize = computed(() => {\n    return parseSizeValue(props.wrapperSize);\n  });\n  const pageFontSize = ref(16);\n\n  const handleWindowResize = () => {\n    pageFontSize.value = parseFloat(getComputedStyle(document.documentElement).fontSize);\n  };\n\n  useEvent(\"resize\", handleWindowResize, true);\n  const itemSizeCalculated = ref(0);\n\n  const calcAverageItemsSize = () => {\n    if (!list.value) {\n      return;\n    }\n\n    const sizes = [];\n    const itemsList = list.value.children;\n    const itemsAmount = itemsList.length;\n\n    for (let i = 0; i < itemsAmount; i++) {\n      const currentChild = list.value.children.item(i);\n      currentChild && sizes.push(currentChild[props.horizontal ? \"clientWidth\" : \"clientHeight\"]);\n    }\n\n    itemSizeCalculated.value = itemsAmount ? Math.trunc(sizes.reduce((acc, el) => acc + el, 0) / (itemsAmount - 1)) : 0;\n  };\n\n  const instance = getCurrentInstance();\n  onMounted(() => {\n    var _a, _b;\n\n    if (!list.value) {\n      list.value = (_b = (_a = instance == null ? void 0 : instance.parent) == null ? void 0 : _a.refs) == null ? void 0 : _b.list;\n    }\n\n    calcAverageItemsSize();\n  });\n  watch(scrollPosition, calcAverageItemsSize);\n  watch(wrapperSize, calcAverageItemsSize);\n  let oldItemSize = 0;\n  const itemSize = computed(() => {\n    const sizeParsed = parseSizeValue(props.itemSize);\n    const result = Math.max(sizeParsed, itemSizeCalculated.value, 1);\n    const diff = Math.abs(oldItemSize / result * 100 - 100);\n\n    if (diff > 5 || oldItemSize === 0) {\n      oldItemSize = result;\n      return result;\n    }\n\n    return oldItemSize;\n  });\n  return {\n    list,\n    wrapper,\n    itemSize,\n    wrapperSize\n  };\n};\n\nexport { useVirtualScrollerSizes as a, useVirtualScrollerSizesProps as u };","map":{"version":3,"mappings":"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","names":["value","isNaN","endsWith","isParsableMeasure","parseInt","validateSizeProp","v","propName","isParsablePositiveMeasure","useVirtualScrollerSizesProps","horizontal","type","Boolean","default","itemSize","Number","String","validator","wrapperSize","props","scrollPosition","list","shallowRef","wrapper","parsedValue","pageFontSize","computed","ref","handleWindowResize","parseFloat","getComputedStyle","document","documentElement","fontSize","useEvent","calcAverageItemsSize","sizes","children","itemsAmount","itemsList","length","i","currentChild","item","push","itemSizeCalculated","Math","trunc","reduce","acc","el","instance","getCurrentInstance","onMounted","parent","refs","watch","oldItemSize","parseSizeValue","result","max","sizeParsed","diff","abs"],"sources":["../../../../../src/components/va-virtual-scroller/useVirtualScrollerSizes.ts"],"sourcesContent":["import {\n  PropType,\n  ExtractPropTypes,\n  ref,\n  Ref,\n  shallowRef,\n  computed,\n  watch,\n  onMounted,\n  getCurrentInstance,\n} from 'vue'\n\nimport { useEvent } from '../../composables'\nimport { warn } from '../../utils/console'\n\n// TODO: Move this to composable?\nexport const isParsableMeasure = (value: unknown): value is string => {\n  if (typeof value === 'string') {\n    return (!isNaN(+value) ||\n      value.endsWith('px') ||\n      value.endsWith('rem'))\n  }\n  return false\n}\n\nexport const isParsablePositiveMeasure = (value: unknown) => {\n  if (typeof value === 'number') {\n    return value >= 0\n  }\n  return isParsableMeasure(value) && parseInt(value) >= 0\n}\n\nconst validateSizeProp = (v: number | string, propName: string) => {\n  const isProperValue = isParsablePositiveMeasure(v)\n\n  !isProperValue &&\n  warn(`[va-virtual-scroller] ${propName} should be number or parsable int greater or equal to 0. Provided: ${v}.`)\n\n  return isProperValue\n}\n\nexport const useVirtualScrollerSizesProps = {\n  horizontal: { type: Boolean, default: false },\n  itemSize: {\n    type: [Number, String] as PropType<string | number>,\n    default: 0,\n    validator: (v: number | string) => { return validateSizeProp(v, 'itemSize') },\n  },\n  wrapperSize: {\n    type: [Number, String] as PropType<string | number>,\n    default: 100,\n    validator: (v: number | string) => { return validateSizeProp(v, 'wrapperSize') },\n  },\n}\n\nexport const useVirtualScrollerSizes = (\n  props: ExtractPropTypes<typeof useVirtualScrollerSizesProps>,\n  scrollPosition: Ref<number>,\n) => {\n  const list = shallowRef<HTMLElement>()\n  const wrapper = shallowRef<HTMLElement>()\n\n  const parseSizeValue = (value: number | string) => {\n    if (typeof value === 'string') {\n      const parsedValue = parseInt(value)\n\n      if (isNaN(parsedValue)) { return 0 }\n\n      return value.endsWith('rem') ? parsedValue * pageFontSize.value : parsedValue\n    }\n    return value\n  }\n\n  const wrapperSize = computed(() => {\n    return parseSizeValue(props.wrapperSize)\n  })\n\n  const pageFontSize = ref(16)\n  const handleWindowResize = () => {\n    pageFontSize.value = parseFloat(getComputedStyle(document.documentElement).fontSize)\n  }\n  useEvent('resize', handleWindowResize, true)\n\n  const itemSizeCalculated = ref(0)\n  const calcAverageItemsSize = () => {\n    if (!list.value) { return }\n\n    const sizes: number[] = []\n    const itemsList = list.value.children\n    const itemsAmount = itemsList.length\n\n    for (let i = 0; i < itemsAmount; i++) {\n      const currentChild = list.value.children.item(i)\n      currentChild && sizes.push(currentChild[props.horizontal ? 'clientWidth' : 'clientHeight'])\n    }\n\n    itemSizeCalculated.value = itemsAmount\n      ? Math.trunc(sizes.reduce((acc, el) => acc + el, 0) / (itemsAmount - 1))\n      : 0\n  }\n\n  const instance = getCurrentInstance()\n  onMounted(() => {\n    if (!list.value) { list.value = instance?.parent?.refs?.list as HTMLElement | undefined }\n    calcAverageItemsSize()\n  })\n  watch(scrollPosition, calcAverageItemsSize)\n  watch(wrapperSize, calcAverageItemsSize)\n\n  let oldItemSize = 0\n  const itemSize = computed(() => {\n    const sizeParsed = parseSizeValue(props.itemSize)\n\n    const result = Math.max(sizeParsed, itemSizeCalculated.value, 1)\n    const diff = Math.abs(((oldItemSize / result) * 100) - 100)\n\n    /**\n     * 5 - empirically derived number, some kind of debounce but without freezes.\n     * While recalculating rendered items average size, if difference is too small, this can cause list 'shaking' because of algorithm:\n     * `rendering items -> calculating their size -> rebuilding list total size -> items offset -> rendering items`\n     * This smoothing is intended to prevent such cases.\n     */\n    if (diff > 5 || oldItemSize === 0) {\n      oldItemSize = result\n      return result\n    }\n\n    return oldItemSize\n  })\n\n  return { list, wrapper, itemSize, wrapperSize }\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { a as isSingleDate, b as isRange, i as isDates } from \"../utils/date-utils.js\";\n\nconst modeInitialValue = (date, mode) => {\n  if (mode === \"single\") {\n    return date;\n  } else if (mode === \"range\") {\n    return {\n      start: date,\n      end: null\n    };\n  } else if (mode === \"multiple\") {\n    return [date];\n  } else if (mode === \"auto\") {\n    return date;\n  }\n\n  throw new Error(\"Unknown mode\");\n};\n\nconst throwIncorrectModelValueError = (modelValue, mode) => {\n  throw Error(`Incorrect modelValue for mode ${mode}. Got ${JSON.stringify(modelValue)}`);\n};\n\nconst modeFromModelValue = modelValue => {\n  if (isSingleDate(modelValue)) {\n    return \"single\";\n  } else if (isRange(modelValue)) {\n    return \"range\";\n  } else if (isDates(modelValue)) {\n    return \"multiple\";\n  }\n\n  return throwIncorrectModelValueError(modelValue, \"auto\");\n};\n\nconst sortRange = modelValue => {\n  if (modelValue.start && modelValue.end) {\n    if (modelValue.start > modelValue.end) {\n      return {\n        start: modelValue.end,\n        end: modelValue.start\n      };\n    }\n  }\n\n  return modelValue;\n};\n\nconst useDatePickerModelValue = (props, emit, dateEqual) => {\n  const updateModelValue = date => {\n    if (!props.modelValue) {\n      emit(\"update:modelValue\", modeInitialValue(date, props.mode));\n      return;\n    }\n\n    const mode = props.mode === \"auto\" ? modeFromModelValue(props.modelValue) : props.mode;\n\n    if (mode === \"single\") {\n      if (!isSingleDate(props.modelValue)) {\n        return throwIncorrectModelValueError(props.modelValue, mode);\n      }\n\n      emit(\"update:modelValue\", date);\n    } else if (mode === \"range\") {\n      if (!isRange(props.modelValue)) {\n        return throwIncorrectModelValueError(props.modelValue, mode);\n      }\n\n      if (props.modelValue.end && dateEqual(props.modelValue.end, date)) {\n        return emit(\"update:modelValue\", {\n          start: props.modelValue.start,\n          end: null\n        });\n      }\n\n      if (props.modelValue.start && dateEqual(props.modelValue.start, date)) {\n        return emit(\"update:modelValue\", {\n          start: null,\n          end: props.modelValue.end\n        });\n      }\n\n      if (props.modelValue.end === null) {\n        return emit(\"update:modelValue\", sortRange({\n          start: props.modelValue.start,\n          end: date\n        }));\n      }\n\n      if (props.modelValue.start === null) {\n        return emit(\"update:modelValue\", sortRange({\n          end: props.modelValue.end,\n          start: date\n        }));\n      }\n\n      emit(\"update:modelValue\", {\n        start: date,\n        end: null\n      });\n    } else if (mode === \"multiple\") {\n      if (!isDates(props.modelValue)) {\n        return throwIncorrectModelValueError(props.modelValue, mode);\n      }\n\n      const isDatesIncludesDate = !!props.modelValue.find(d => dateEqual(d, date));\n\n      if (isDatesIncludesDate) {\n        emit(\"update:modelValue\", props.modelValue.filter(d => !dateEqual(d, date)));\n      } else {\n        emit(\"update:modelValue\", [...props.modelValue, date].sort((a, b) => a.getTime() - b.getTime()));\n      }\n    }\n  };\n\n  return {\n    updateModelValue\n  };\n};\n\nexport { useDatePickerModelValue as u };","map":{"version":3,"mappings":"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","names":["modeInitialValue","date","mode","start","end","Error","throwIncorrectModelValueError","modelValue","JSON","stringify","modeFromModelValue","isRange","isDates","sortRange","useDatePickerModelValue","props","emit","dateEqual","isSingleDate","find","d","isDatesIncludesDate","filter","sort","a","b","getTime","updateModelValue"],"sources":["../../../../../../src/components/va-date-picker/hooks/model-value-helper.ts"],"sourcesContent":["import { isRange, isSingleDate, isDates } from '../utils/date-utils'\nimport { DatePickerModelValue, DatePickerRange, DatePickerMode } from '../types'\n\nconst modeInitialValue = (date: Date, mode: DatePickerMode) => {\n  if (mode === 'single') {\n    return date\n  } else if (mode === 'range') {\n    return { start: date, end: null }\n  } else if (mode === 'multiple') {\n    return [date]\n  } else if (mode === 'auto') {\n    return date\n  }\n\n  throw new Error('Unknown mode')\n}\n\nconst throwIncorrectModelValueError = (modelValue: DatePickerModelValue, mode: DatePickerMode) : never => {\n  throw Error(`Incorrect modelValue for mode ${mode}. Got ${JSON.stringify(modelValue)}`)\n}\n\nconst modeFromModelValue = (modelValue: DatePickerModelValue): DatePickerMode => {\n  if (isSingleDate(modelValue)) {\n    return 'single'\n  } else if (isRange(modelValue)) {\n    return 'range'\n  } else if (isDates(modelValue)) {\n    return 'multiple'\n  }\n\n  return throwIncorrectModelValueError(modelValue, 'auto')\n}\n\nconst sortRange = (modelValue: DatePickerRange) => {\n  if (modelValue.start && modelValue.end) {\n    if (modelValue.start > modelValue.end) {\n      return { start: modelValue.end, end: modelValue.start }\n    }\n  }\n\n  return modelValue\n}\n\nexport const useDatePickerModelValue = (\n  props: {\n    [key: string]: any,\n    modelValue?: DatePickerModelValue,\n    mode: DatePickerMode\n  },\n  emit: (event: 'update:modelValue', newValue: DatePickerModelValue) => any,\n  dateEqual: (date1?: Date | null, date2?: Date | null) => boolean,\n) => {\n  const updateModelValue = (date: Date) => {\n    if (!props.modelValue) {\n      emit('update:modelValue', modeInitialValue(date, props.mode))\n      return\n    }\n\n    const mode = props.mode === 'auto' ? modeFromModelValue(props.modelValue) : props.mode\n\n    if (mode === 'single') {\n      if (!isSingleDate(props.modelValue)) {\n        return throwIncorrectModelValueError(props.modelValue, mode)\n      }\n\n      emit('update:modelValue', date)\n    } else if (mode === 'range') {\n      if (!isRange(props.modelValue)) {\n        return throwIncorrectModelValueError(props.modelValue, mode)\n      }\n\n      if (props.modelValue.end && dateEqual(props.modelValue.end, date)) {\n        return emit('update:modelValue', { start: props.modelValue.start, end: null })\n      }\n      if (props.modelValue.start && dateEqual(props.modelValue.start, date)) {\n        return emit('update:modelValue', { start: null, end: props.modelValue.end })\n      }\n\n      if (props.modelValue.end === null) {\n        return emit('update:modelValue', sortRange({ start: props.modelValue.start, end: date }))\n      }\n      if (props.modelValue.start === null) {\n        return emit('update:modelValue', sortRange({ end: props.modelValue.end, start: date }))\n      }\n\n      emit('update:modelValue', { start: date, end: null })\n    } else if (mode === 'multiple') {\n      if (!isDates(props.modelValue)) {\n        return throwIncorrectModelValueError(props.modelValue, mode)\n      }\n\n      const isDatesIncludesDate = !!props.modelValue.find((d) => dateEqual(d, date))\n\n      if (isDatesIncludesDate) {\n        emit('update:modelValue', props.modelValue.filter((d) => !dateEqual(d, date)))\n      } else {\n        emit('update:modelValue', [...props.modelValue, date].sort((a, b) => a.getTime() - b.getTime()))\n      }\n    }\n  }\n\n  return {\n    updateModelValue,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
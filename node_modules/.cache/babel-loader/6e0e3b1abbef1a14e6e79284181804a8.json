{"ast":null,"code":"import { ref, computed, watch } from \"vue\";\nimport { g as getItemKey } from \"./useRows.js\";\n\nfunction useSelectableRow(paginatedRows, props, emit) {\n  const selectedItemsFallback = ref([]);\n  const selectedItemsSync = computed({\n    get() {\n      if (props.modelValue === void 0) {\n        return selectedItemsFallback.value;\n      } else {\n        return props.modelValue;\n      }\n    },\n\n    set(modelValue) {\n      if (props.modelValue === void 0) {\n        selectedItemsFallback.value = modelValue;\n      }\n\n      emit(\"update:modelValue\", modelValue);\n    }\n\n  });\n  const prevSelectedRowIndex = ref(-1);\n  watch(() => props.selectMode, (newSelectMode, oldSelectMode) => {\n    if (newSelectMode === \"single\" && oldSelectMode === \"multiple\") {\n      selectedItemsSync.value = [];\n      setPrevSelectedRowIndex(-1);\n    }\n  });\n  watch(paginatedRows, () => {\n    setPrevSelectedRowIndex(-1);\n  });\n  watch(selectedItemsSync, (currentSelectedItems, previousSelectedItems = []) => {\n    emit(\"selectionChange\", {\n      currentSelectedItems,\n      previousSelectedItems\n    });\n  }, {\n    immediate: true\n  });\n\n  const getKey = source => getItemKey(source, props.itemsTrackBy);\n\n  const noRowsSelected = computed(() => !paginatedRows.value.some(({\n    source\n  }) => selectedItemsSync.value.includes(getKey(source))));\n  const allRowsSelected = computed(() => {\n    if (paginatedRows.value.length === 0) {\n      return false;\n    }\n\n    return paginatedRows.value.every(({\n      source\n    }) => selectedItemsSync.value.includes(getKey(source)));\n  });\n  const severalRowsSelected = computed(() => !noRowsSelected.value && !allRowsSelected.value);\n\n  function isRowSelected(row) {\n    return selectedItemsSync.value.includes(getKey(row.source));\n  }\n\n  function selectAllRows() {\n    selectedItemsSync.value = [... /* @__PURE__ */new Set([...selectedItemsSync.value, ...paginatedRows.value.map(row => getKey(row.source))])];\n  }\n\n  function unselectAllRows() {\n    const paginatedRowsKeys = paginatedRows.value.map(row => getKey(row.source));\n    selectedItemsSync.value = selectedItemsSync.value.filter(item => !paginatedRowsKeys.includes(item));\n  }\n\n  function selectRow(row) {\n    selectedItemsSync.value = [...selectedItemsSync.value, getKey(row.source)];\n  }\n\n  function selectOnlyRow(row) {\n    selectedItemsSync.value = [getKey(row.source)];\n  }\n\n  function unselectRow(row) {\n    const index = selectedItemsSync.value.findIndex(item => item === getKey(row.source));\n    selectedItemsSync.value = [...selectedItemsSync.value.slice(0, index), ...selectedItemsSync.value.slice(index + 1)];\n  }\n\n  function setPrevSelectedRowIndex(rowInitialIndex) {\n    if (rowInitialIndex === -1) {\n      prevSelectedRowIndex.value = -1;\n    } else {\n      const prevSelectedRow = paginatedRows.value.find(row => row.initialIndex === rowInitialIndex);\n      prevSelectedRow ? prevSelectedRowIndex.value = paginatedRows.value.indexOf(prevSelectedRow) : prevSelectedRowIndex.value = -1;\n    }\n  }\n\n  function getRowsToSelect(targetIndex) {\n    let start;\n    let end;\n\n    if (isRowSelected(paginatedRows.value[prevSelectedRowIndex.value])) {\n      start = Math.min(prevSelectedRowIndex.value, targetIndex);\n      end = Math.max(prevSelectedRowIndex.value, targetIndex);\n    } else {\n      start = Math.min(prevSelectedRowIndex.value + 1, targetIndex);\n      end = Math.max(prevSelectedRowIndex.value - 1, targetIndex);\n    }\n\n    return paginatedRows.value.slice(start, end + 1);\n  }\n\n  function mergeSelection(rowsToSelect) {\n    const rowsToSelectedItems = rowsToSelect.map(row => getKey(row.source));\n\n    if (noRowsSelected.value) {\n      selectedItemsSync.value = rowsToSelectedItems;\n      return;\n    }\n\n    const isInternalSelection = rowsToSelectedItems.every(item => selectedItemsSync.value.includes(item));\n\n    if (isInternalSelection) {\n      selectedItemsSync.value = selectedItemsSync.value.filter(item => !rowsToSelectedItems.includes(item));\n      return;\n    }\n\n    selectedItemsSync.value = [... /* @__PURE__ */new Set([...selectedItemsSync.value, ...rowsToSelectedItems])];\n  }\n\n  function toggleRowSelection(row) {\n    if (!props.selectable) {\n      return;\n    }\n\n    if (isRowSelected(row)) {\n      unselectRow(row);\n      props.selectMode === \"single\" ? setPrevSelectedRowIndex(-1) : setPrevSelectedRowIndex(row.initialIndex);\n    } else {\n      props.selectMode === \"single\" ? selectOnlyRow(row) : selectRow(row);\n      setPrevSelectedRowIndex(row.initialIndex);\n    }\n  }\n\n  function ctrlSelectRow(row) {\n    if (!props.selectable) {\n      return;\n    }\n\n    toggleRowSelection(row);\n  }\n\n  function shiftSelectRows(row) {\n    if (!props.selectable) {\n      return;\n    }\n\n    if (props.selectMode === \"single\" || prevSelectedRowIndex.value === -1) {\n      return toggleRowSelection(row);\n    }\n\n    const targetIndex = paginatedRows.value.indexOf(row);\n    mergeSelection(getRowsToSelect(targetIndex));\n    setPrevSelectedRowIndex(-1);\n  }\n\n  function toggleBulkSelection() {\n    if (allRowsSelected.value) {\n      unselectAllRows();\n    } else {\n      selectAllRows();\n    }\n\n    setPrevSelectedRowIndex(-1);\n  }\n\n  return {\n    ctrlSelectRow,\n    shiftSelectRows,\n    toggleRowSelection,\n    toggleBulkSelection,\n    isRowSelected,\n    noRowsSelected,\n    severalRowsSelected,\n    allRowsSelected\n  };\n}\n\nexport { useSelectableRow as u };","map":{"version":3,"mappings":"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","names":["props","emit","ref","selectedItemsSync","computed","get","modelValue","selectedItemsFallback","value","set","watch","selectMode","newSelectMode","oldSelectMode","setPrevSelectedRowIndex","paginatedRows","currentSelectedItems","previousSelectedItems","immediate","getKey","source","getItemKey","itemsTrackBy","noRowsSelected","some","includes","length","every","allRowsSelected","row","Set","map","filter","item","paginatedRowsKeys","findIndex","slice","index","rowInitialIndex","prevSelectedRowIndex","prevSelectedRow","find","initialIndex","indexOf","targetIndex","isRowSelected","start","Math","min","end","max","rowsToSelect","rowsToSelectedItems","isInternalSelection","selectable","unselectRow","selectOnlyRow","selectRow","toggleRowSelection","mergeSelection","unselectAllRows","selectAllRows","ctrlSelectRow","shiftSelectRows","toggleBulkSelection","severalRowsSelected"],"sources":["../../../../../../src/components/va-data-table/hooks/useSelectableRow.ts"],"sourcesContent":["import { Ref, computed, watch, ref } from 'vue'\n\nimport { getItemKey } from './useRows'\n\nimport type { DataTableRow, DataTableItem, DataTableSelectMode, DataTableItemKey } from '../types'\n\ninterface useSelectableProps {\n  modelValue: (DataTableItem | DataTableItemKey)[] | undefined // selectedItems\n  selectable: boolean\n  selectMode: DataTableSelectMode\n  itemsTrackBy: string | ((item: DataTableItem) => any)\n  [prop: string]: unknown\n}\nexport type TEmits = 'update:modelValue' | 'selectionChange'\nexport type TSelectionChange = {\n  currentSelectedItems: (DataTableItem | DataTableItemKey)[],\n  previousSelectedItems: (DataTableItem | DataTableItemKey)[],\n}\nexport type TSelectableEmits = (event: TEmits, arg: (DataTableItem | DataTableItemKey)[] | TSelectionChange) => void\n\nexport default function useSelectableRow (\n  paginatedRows: Ref<DataTableRow[]>,\n  props: useSelectableProps,\n  emit: TSelectableEmits,\n) {\n  const selectedItemsFallback = ref<(DataTableItem | DataTableItemKey)[]>([])\n\n  const selectedItemsSync = computed<(DataTableItem | DataTableItemKey)[]>({\n    get () {\n      if (props.modelValue === undefined) {\n        return selectedItemsFallback.value\n      } else {\n        return props.modelValue\n      }\n    },\n\n    set (modelValue) {\n      if (props.modelValue === undefined) {\n        selectedItemsFallback.value = modelValue\n      }\n\n      emit('update:modelValue', modelValue)\n    },\n  })\n\n  const prevSelectedRowIndex = ref(-1)\n\n  // clear all the selected rows when the `select-mode`'s value changes from multiple to single\n  // (though it's safe enough to leave a selected item when changing from single to multiple\n  watch(() => props.selectMode, (newSelectMode, oldSelectMode) => {\n    if (newSelectMode === 'single' && oldSelectMode === 'multiple') {\n      selectedItemsSync.value = []\n      setPrevSelectedRowIndex(-1)\n    }\n  })\n\n  // watch for rows changes (happens when filtering is applied e.g.)\n  watch(paginatedRows, () => { setPrevSelectedRowIndex(-1) })\n\n  // emit the \"selection-change\" event each time the selection changes\n  watch(selectedItemsSync, (currentSelectedItems, previousSelectedItems = []) => {\n    emit('selectionChange', {\n      currentSelectedItems,\n      previousSelectedItems,\n    })\n  }, { immediate: true })\n\n  // if user provide `props.itemsTrackBy !== ''` than `selectedItemsSync` and `props.modelValue`\n  // would be the array with keys (received from `props.itemsTrackBy`)\n  // else they would be the array with source (`DataTableItem` type)\n  const getKey = (source: DataTableItem) => getItemKey(source, props.itemsTrackBy)\n\n  const noRowsSelected = computed(() => (\n    !paginatedRows.value.some(({ source }) => selectedItemsSync.value.includes(getKey(source)))\n  ))\n\n  const allRowsSelected = computed(() => {\n    if (paginatedRows.value.length === 0) { return false }\n\n    return paginatedRows.value.every(({ source }) => selectedItemsSync.value.includes(getKey(source)))\n  })\n\n  const severalRowsSelected = computed(() => !noRowsSelected.value && !allRowsSelected.value)\n\n  function isRowSelected (row: DataTableRow) {\n    return selectedItemsSync.value.includes(getKey(row.source))\n  }\n\n  function selectAllRows () {\n    selectedItemsSync.value = [...new Set([\n      ...selectedItemsSync.value,\n      ...paginatedRows.value.map(row => getKey(row.source)),\n    ])]\n  }\n\n  function unselectAllRows () {\n    const paginatedRowsKeys = paginatedRows.value.map(row => getKey(row.source))\n\n    selectedItemsSync.value = selectedItemsSync.value\n      .filter((item) => !paginatedRowsKeys.includes(item))\n  }\n\n  // The one calling this function must guarantee that the row isn't already selected\n  function selectRow (row: DataTableRow) {\n    selectedItemsSync.value = [...selectedItemsSync.value, getKey(row.source)]\n  }\n\n  function selectOnlyRow (row: DataTableRow) {\n    selectedItemsSync.value = [getKey(row.source)]\n  }\n\n  // The one calling this function must guarantee that the row is selected\n  function unselectRow (row: DataTableRow) {\n    const index = selectedItemsSync.value.findIndex(item => item === getKey(row.source))\n\n    selectedItemsSync.value = [\n      ...selectedItemsSync.value.slice(0, index),\n      ...selectedItemsSync.value.slice(index + 1),\n    ]\n  }\n\n  function setPrevSelectedRowIndex (rowInitialIndex: number) {\n    if (rowInitialIndex === -1) {\n      prevSelectedRowIndex.value = -1\n    } else {\n      const prevSelectedRow = paginatedRows.value.find(row => row.initialIndex === rowInitialIndex)\n\n      prevSelectedRow\n        ? prevSelectedRowIndex.value = paginatedRows.value.indexOf(prevSelectedRow)\n        : prevSelectedRowIndex.value = -1\n    }\n  }\n\n  function getRowsToSelect (targetIndex: number) {\n    let start\n    let end\n\n    if (isRowSelected(paginatedRows.value[prevSelectedRowIndex.value])) {\n      start = Math.min(prevSelectedRowIndex.value, targetIndex)\n      end = Math.max(prevSelectedRowIndex.value, targetIndex)\n    } else {\n      start = Math.min(prevSelectedRowIndex.value + 1, targetIndex)\n      end = Math.max(prevSelectedRowIndex.value - 1, targetIndex)\n    }\n\n    return paginatedRows.value.slice(start, end + 1)\n  }\n\n  function mergeSelection (rowsToSelect: DataTableRow[]) {\n    const rowsToSelectedItems = rowsToSelect.map(row => getKey(row.source))\n\n    if (noRowsSelected.value) {\n      selectedItemsSync.value = rowsToSelectedItems\n      return\n    }\n\n    const isInternalSelection = rowsToSelectedItems.every(item => selectedItemsSync.value.includes(item))\n\n    if (isInternalSelection) {\n      selectedItemsSync.value = selectedItemsSync.value.filter(item => !rowsToSelectedItems.includes(item))\n      return\n    }\n\n    selectedItemsSync.value = [...new Set([\n      ...selectedItemsSync.value,\n      ...rowsToSelectedItems,\n    ])]\n  }\n\n  function toggleRowSelection (row: DataTableRow) {\n    if (!props.selectable) {\n      return\n    }\n\n    if (isRowSelected(row)) {\n      unselectRow(row)\n      props.selectMode === 'single' ? setPrevSelectedRowIndex(-1) : setPrevSelectedRowIndex(row.initialIndex)\n    } else {\n      props.selectMode === 'single' ? selectOnlyRow(row) : selectRow(row)\n      setPrevSelectedRowIndex(row.initialIndex)\n    }\n  }\n\n  function ctrlSelectRow (row: DataTableRow) {\n    if (!props.selectable) {\n      return\n    }\n\n    toggleRowSelection(row)\n  }\n\n  function shiftSelectRows (row: DataTableRow) {\n    if (!props.selectable) {\n      return\n    }\n\n    if (props.selectMode === 'single' || prevSelectedRowIndex.value === -1) {\n      return toggleRowSelection(row)\n    }\n\n    const targetIndex = paginatedRows.value.indexOf(row)\n    mergeSelection(getRowsToSelect(targetIndex))\n    setPrevSelectedRowIndex(-1)\n  }\n\n  function toggleBulkSelection () {\n    if (allRowsSelected.value) {\n      unselectAllRows()\n    } else {\n      selectAllRows()\n    }\n\n    setPrevSelectedRowIndex(-1)\n  }\n\n  return {\n    ctrlSelectRow,\n    shiftSelectRows,\n    toggleRowSelection,\n    toggleBulkSelection,\n    isRowSelected,\n    noRowsSelected,\n    severalRowsSelected,\n    allRowsSelected,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
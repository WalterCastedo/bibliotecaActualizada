{"ast":null,"code":"import { computed } from \"vue\";\nimport { m as merge_1, s as startCase_1 } from \"../../../../vendor.js\";\nimport { w as warn } from \"../../../utils/console.js\";\n\nconst sortingOptionsValidator = options => {\n  const isAllowedOptionsLength = options.length === 2 || options.length === 3;\n  const isAvailableOptions = options.every(option => [\"asc\", \"desc\", null].includes(option));\n  const isUniqueOptions = options.length === new Set(options).size;\n  return isAllowedOptionsLength && isAvailableOptions && isUniqueOptions;\n};\n\nconst buildTableColumn = (source, initialIndex, props) => {\n  const input = typeof source === \"string\" ? {\n    key: source\n  } : source;\n  const isValidOptions = input.sortingOptions ? sortingOptionsValidator(input.sortingOptions) : true;\n\n  if (!isValidOptions) {\n    warn(`The \"sortingOptions\" array in the column with \"${input.key}\" key is invalid. For this column, the \"sortingOptions\" value is taken as for the table: ${JSON.stringify(props.sortingOptions)}.`);\n  }\n\n  return {\n    source,\n    initialIndex,\n    key: input.key,\n    name: input.name || input.key,\n    label: input.label || startCase_1(input.key),\n    thTitle: input.thTitle || input.headerTitle || input.label || startCase_1(input.key),\n    sortable: input.sortable || false,\n    sortingFn: input.sortingFn,\n    sortingOptions: isValidOptions && input.sortingOptions || props.sortingOptions,\n    thAlign: input.thAlign || input.alignHead || \"left\",\n    thVerticalAlign: input.thVerticalAlign || input.verticalAlignHead || \"middle\",\n    tdAlign: input.tdAlign || input.align || \"left\",\n    tdVerticalAlign: input.tdVerticalAlign || input.verticalAlign || \"middle\",\n    width: input.width,\n    tdClass: input.tdClass || input.classes,\n    thClass: input.thClass || input.headerClasses,\n    tdStyle: input.tdStyle || input.style,\n    thStyle: input.thStyle || input.headerStyle\n  };\n};\n\nconst buildColumnsFromItems = props => {\n  return Object.keys(merge_1({}, ...props.items)).map((item, index) => buildTableColumn(item, index, props));\n};\n\nconst buildNormalizedColumns = props => {\n  return props.columns.map((item, index) => buildTableColumn(item, index, props));\n};\n\nfunction useColumns(props) {\n  const columnsComputed = computed(() => {\n    if (props.columns.length === 0) {\n      return buildColumnsFromItems(props);\n    } else {\n      return buildNormalizedColumns(props);\n    }\n  });\n  return {\n    columnsComputed\n  };\n}\n\nexport { sortingOptionsValidator as s, useColumns as u };","map":{"version":3,"mappings":"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","names":["options","isAllowedOptionsLength","length","isAvailableOptions","every","option","includes","isUniqueOptions","Set","size","buildTableColumn","source","initialIndex","props","input","key","isValidOptions","sortingOptions","sortingOptionsValidator","warn","JSON","stringify","name","label","startCase","thTitle","headerTitle","sortable","sortingFn","thAlign","alignHead","thVerticalAlign","verticalAlignHead","tdAlign","align","tdVerticalAlign","verticalAlign","width","tdClass","classes","thClass","headerClasses","tdStyle","style","thStyle","headerStyle","buildColumnsFromItems","Object","keys","merge","items","map","item","index","buildNormalizedColumns","columns","computed","columnsComputed"],"sources":["../../../../../../src/components/va-data-table/hooks/useColumns.ts"],"sourcesContent":["import { computed } from 'vue'\nimport startCase from 'lodash/startCase.js'\nimport merge from 'lodash/merge.js'\n\nimport { warn } from '../../../utils/console'\nimport type {\n  DataTableColumnSource,\n  DataTableColumnInternal,\n  DataTableItem,\n  DataTableSortingOptions,\n} from '../types'\n\ninterface useColumnsProps {\n  columns: DataTableColumnSource[]\n  items: DataTableItem[]\n  sortingOptions: DataTableSortingOptions\n  [prop: string]: unknown\n}\n\nexport const sortingOptionsValidator = (options: DataTableSortingOptions) => {\n  const isAllowedOptionsLength = options.length === 2 || options.length === 3\n  const isAvailableOptions = options.every((option) => ['asc', 'desc', null].includes(option))\n  const isUniqueOptions = (options.length === new Set(options).size)\n\n  return isAllowedOptionsLength && isAvailableOptions && isUniqueOptions\n}\n\nexport const buildTableColumn = (\n  source: DataTableColumnSource,\n  initialIndex: number,\n  props: useColumnsProps,\n): DataTableColumnInternal => {\n  const input = typeof source === 'string' ? { key: source } : source\n\n  const isValidOptions = input.sortingOptions\n    ? sortingOptionsValidator(input.sortingOptions)\n    : true\n\n  if (!isValidOptions) {\n    warn(`The \"sortingOptions\" array in the column with \"${input.key}\" key is invalid. For this column, the \"sortingOptions\" value is taken as for the table: ${JSON.stringify(props.sortingOptions)}.`)\n  }\n\n  return {\n    source,\n    initialIndex,\n    key: input.key,\n    name: input.name || input.key,\n    label: input.label || startCase(input.key),\n    thTitle: input.thTitle || input.headerTitle || input.label || startCase(input.key),\n    sortable: input.sortable || false,\n    sortingFn: input.sortingFn,\n    sortingOptions: (isValidOptions && input.sortingOptions) || props.sortingOptions,\n    thAlign: input.thAlign || input.alignHead || 'left',\n    thVerticalAlign: input.thVerticalAlign || input.verticalAlignHead || 'middle',\n    tdAlign: input.tdAlign || input.align || 'left',\n    tdVerticalAlign: input.tdVerticalAlign || input.verticalAlign || 'middle',\n    width: input.width,\n    tdClass: input.tdClass || input.classes,\n    thClass: input.thClass || input.headerClasses,\n    tdStyle: input.tdStyle || input.style,\n    thStyle: input.thStyle || input.headerStyle,\n  }\n}\n\nconst buildColumnsFromItems = (props: useColumnsProps) => {\n  return Object.keys(merge({}, ...props.items)).map((item, index) => buildTableColumn(item, index, props))\n}\n\nconst buildNormalizedColumns = (props: useColumnsProps) => {\n  return props.columns.map((item, index) => buildTableColumn(item, index, props))\n}\n\nexport default function useColumns (props: useColumnsProps) {\n  const columnsComputed = computed(() => {\n    if (props.columns.length === 0) {\n      // if no column definitions provided then build them based on provided rawItems\n      // e.g. if provided items look like `[{a: 1}, {b: 2}]` then there should be 2 columns: A and B\n      return buildColumnsFromItems(props)\n    } else {\n      return buildNormalizedColumns(props)\n    }\n  })\n\n  return {\n    columnsComputed,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { ref, reactive, watchEffect, watch } from \"vue\";\nimport { u as useEvent } from \"./useEvent.js\";\nconst mouseEvents = [\"mousedown\", \"mousemove\"];\nconst touchEvents = [\"touchstart\", \"touchmove\"];\nconst commonAllowedDirections = {\n  vertical: [\"\", \"all\", \"vertical\"],\n  horizontal: [\"\", \"all\", \"horizontal\"]\n};\nconst verticalSpecificAllowedDirections = [...commonAllowedDirections.vertical, \"up\", \"down\"];\nconst horizontalSpecificAllowedDirections = [...commonAllowedDirections.horizontal, \"left\", \"right\"];\nconst useSwipeProps = {\n  swipable: {\n    type: Boolean,\n    default: false\n  },\n  swipeDistance: {\n    type: Number,\n    default: 75\n  },\n  swipeDirection: {\n    type: String,\n    default: \"all\"\n  }\n};\n\nconst useSwipe = (props, container, cb) => {\n  const swipeStarted = ref(false);\n  const swipePath = reactive({\n    start: {\n      x: 0,\n      y: 0\n    },\n    end: {\n      x: 0,\n      y: 0\n    }\n  });\n  const swipeDuration = reactive({\n    start: 0,\n    end: 0\n  });\n\n  const setState = (e, type) => {\n    let event;\n\n    if (mouseEvents.includes(e.type)) {\n      event = e;\n    }\n\n    if (touchEvents.includes(e.type)) {\n      const touchEvent = e;\n      event = touchEvent.changedTouches[touchEvent.changedTouches.length - 1];\n    }\n\n    if (!event) {\n      return;\n    }\n\n    swipePath[type].x = event.pageX;\n    swipePath[type].y = event.pageY;\n    swipeDuration[type] = new Date().getTime();\n  };\n\n  const onSwipeStart = e => {\n    if (!props.swipable || swipeStarted.value) {\n      return;\n    }\n\n    swipeStarted.value = true;\n    setState(e, \"start\");\n  };\n\n  const onSwipeMove = e => {\n    if (!swipeStarted.value) {\n      return;\n    }\n\n    setState(e, \"end\");\n  };\n\n  const resetSwipe = () => {\n    [\"start\", \"end\"].forEach(type => {\n      swipePath[type].x = 0;\n      swipePath[type].y = 0;\n      swipeDuration[type] = 0;\n    });\n    swipeStarted.value = false;\n  };\n\n  const isSwipeAllowed = reactive({\n    vertical: false,\n    horizontal: false\n  });\n  watchEffect(() => {\n    isSwipeAllowed.horizontal = horizontalSpecificAllowedDirections.includes(props.swipeDirection);\n    isSwipeAllowed.vertical = verticalSpecificAllowedDirections.includes(props.swipeDirection);\n  });\n\n  const calcDistance = axis => {\n    return isSwipeAllowed[axis === \"x\" ? \"horizontal\" : \"vertical\"] && swipePath.start[axis] && swipePath.end[axis] ? Math.trunc(swipePath.start[axis] - swipePath.end[axis]) : 0;\n  };\n\n  const getAcceptableValue = (direction, result) => {\n    return result === props.swipeDirection || commonAllowedDirections[direction].includes(props.swipeDirection) ? result : \"\";\n  };\n\n  const swipeState = reactive({\n    direction: \"\",\n    duration: 0\n  });\n  watch(swipePath, () => {\n    const xDistance = calcDistance(\"x\");\n    const yDistance = calcDistance(\"y\");\n\n    if ((xDistance || yDistance) && [xDistance, yDistance].some(el => Math.abs(el) >= props.swipeDistance)) {\n      if (Math.abs(xDistance) >= Math.abs(yDistance) && isSwipeAllowed.horizontal) {\n        const result = xDistance > 0 ? \"left\" : \"right\";\n        swipeState.direction = getAcceptableValue(\"horizontal\", result);\n      } else if (Math.abs(xDistance) < Math.abs(yDistance) && isSwipeAllowed.vertical) {\n        const result = yDistance > 0 ? \"down\" : \"up\";\n        swipeState.direction = getAcceptableValue(\"vertical\", result);\n      }\n\n      swipeState.duration = swipeDuration.end - swipeDuration.start;\n      resetSwipe();\n    }\n  }, {\n    deep: true\n  });\n  watch(swipeState, () => cb(swipeState), {\n    deep: true\n  });\n\n  if (props.swipable) {\n    useEvent([\"touchstart\", \"mousedown\"], onSwipeStart, container);\n    useEvent([\"touchmove\", \"mousemove\"], onSwipeMove, container);\n    useEvent([\"touchcancel\", \"mouseup\", \"touchend\", \"mouseleave\"], resetSwipe, container);\n  }\n\n  return {\n    swipeState\n  };\n};\n\nexport { useSwipe as a, useSwipeProps as u };","map":{"version":3,"mappings":"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","names":["mouseEvents","touchEvents","commonAllowedDirections","vertical","horizontal","verticalSpecificAllowedDirections","horizontalSpecificAllowedDirections","useSwipeProps","swipable","type","Boolean","default","swipeDistance","Number","swipeDirection","String","useSwipe","props","container","cb","ref","swipePath","reactive","start","x","y","end","swipeDuration","e","includes","event","touchEvent","changedTouches","length","pageX","pageY","Date","getTime","swipeStarted","value","setState","resetSwipe","forEach","isSwipeAllowed","watchEffect","axis","Math","trunc","direction","result","swipeState","duration","watch","calcDistance","xDistance","yDistance","some","el","abs","getAcceptableValue","deep","useEvent","onSwipeStart","onSwipeMove"],"sources":["../../../../src/composables/useSwipe.ts"],"sourcesContent":["import { ref, reactive, watch, PropType, ShallowRef, ExtractPropTypes, watchEffect } from 'vue'\n\nimport { useEvent } from './'\n\ntype SwipeDirection = 'up' | 'down' | 'left' | 'right' | ''\ntype SwipePosition = 'start' | 'end'\ntype SwipeCoordinates = Record<'x' | 'y', number>\ntype SwipePath = Record<SwipePosition, SwipeCoordinates>\nexport type SwipeState = { direction: SwipeDirection, duration: number }\n\ntype AllowedSwipeDirection = 'all' | 'horizontal' | 'vertical' | SwipeDirection\n\nconst mouseEvents = ['mousedown', 'mousemove']\nconst touchEvents = ['touchstart', 'touchmove']\n\nconst commonAllowedDirections = {\n  vertical: ['', 'all', 'vertical'],\n  horizontal: ['', 'all', 'horizontal'],\n}\nconst verticalSpecificAllowedDirections = [...commonAllowedDirections.vertical, 'up', 'down']\nconst horizontalSpecificAllowedDirections = [...commonAllowedDirections.horizontal, 'left', 'right']\n\n/**\n * swipable - enables swiping.\n * swipeDistance - distance in px considered sufficient for the swipe event.\n * swipeDirection - allowed and handled swipe directions.\n */\nexport const useSwipeProps = {\n  swipable: { type: Boolean, default: false },\n  swipeDistance: { type: Number, default: 75 },\n  swipeDirection: { type: String as PropType<AllowedSwipeDirection>, default: 'all' },\n}\n\n/**\n * @description composable for handling swipes direction via mouse or touchpad.\n * @param props - use swipe props.\n * @param container - swipable container shallow ref.\n * @param cb - callback for every swipe event.\n * @example\n *  props: { ...useSwipeProps }\n *  const container = shallowRef<HTMLElement>()\n *  const onSwipe = () => { if(swipeState === 'left') { local component's logic } }\n *  const { swipeState } = useSwipe(props, container, onSwipe)\n */\nexport const useSwipe = (\n  props: ExtractPropTypes<typeof useSwipeProps>,\n  container: ShallowRef<HTMLElement | undefined>,\n  cb: (state: SwipeState) => void,\n) => {\n  const swipeStarted = ref(false)\n  const swipePath = reactive({\n    start: { x: 0, y: 0 },\n    end: { x: 0, y: 0 },\n  }) as SwipePath\n  const swipeDuration = reactive({\n    start: 0,\n    end: 0,\n  })\n\n  const setState = (e: TouchEvent | MouseEvent, type: SwipePosition) => {\n    let event: MouseEvent | Touch | undefined\n    if (mouseEvents.includes(e.type)) { event = e as MouseEvent }\n    if (touchEvents.includes(e.type)) {\n      const touchEvent = e as TouchEvent\n      event = touchEvent.changedTouches[touchEvent.changedTouches.length - 1]\n    }\n    if (!event) { return }\n\n    swipePath[type].x = event.pageX\n    swipePath[type].y = event.pageY\n    swipeDuration[type] = new Date().getTime()\n  }\n\n  const onSwipeStart = (e: TouchEvent | MouseEvent) => {\n    if (!props.swipable || swipeStarted.value) { return }\n    swipeStarted.value = true\n    setState(e, 'start')\n  }\n\n  const onSwipeMove = (e: TouchEvent | MouseEvent) => {\n    if (!swipeStarted.value) { return }\n    setState(e, 'end')\n  }\n\n  const resetSwipe = () => {\n    (['start', 'end'] as SwipePosition[]).forEach((type) => {\n      swipePath[type].x = 0\n      swipePath[type].y = 0\n      swipeDuration[type] = 0\n    })\n    swipeStarted.value = false\n  }\n\n  const isSwipeAllowed = reactive({\n    vertical: false,\n    horizontal: false,\n  })\n  watchEffect(() => {\n    isSwipeAllowed.horizontal = horizontalSpecificAllowedDirections.includes(props.swipeDirection)\n    isSwipeAllowed.vertical = verticalSpecificAllowedDirections.includes(props.swipeDirection)\n  })\n\n  const calcDistance = (axis: 'x' | 'y') => {\n    return isSwipeAllowed[axis === 'x' ? 'horizontal' : 'vertical'] &&\n    swipePath.start[axis] && swipePath.end[axis]\n      ? Math.trunc(swipePath.start[axis] - swipePath.end[axis])\n      : 0\n  }\n\n  const getAcceptableValue = (direction: 'horizontal' | 'vertical', result: SwipeDirection) => {\n    return result === props.swipeDirection || commonAllowedDirections[direction].includes(props.swipeDirection) ? result : ''\n  }\n\n  const swipeState = reactive({ direction: '', duration: 0 }) as SwipeState\n  watch(swipePath, () => {\n    const xDistance = calcDistance('x')\n    const yDistance = calcDistance('y')\n\n    if ((xDistance || yDistance) && [xDistance, yDistance].some((el) => Math.abs(el) >= props.swipeDistance)) {\n      if (Math.abs(xDistance) >= Math.abs(yDistance) && isSwipeAllowed.horizontal) {\n        const result = xDistance > 0 ? 'left' : 'right'\n        swipeState.direction = getAcceptableValue('horizontal', result)\n      } else if (Math.abs(xDistance) < Math.abs(yDistance) && isSwipeAllowed.vertical) {\n        const result = yDistance > 0 ? 'down' : 'up'\n        swipeState.direction = getAcceptableValue('vertical', result)\n      }\n\n      swipeState.duration = swipeDuration.end - swipeDuration.start\n\n      resetSwipe()\n    }\n  }, { deep: true })\n\n  watch(swipeState, () => cb(swipeState), { deep: true })\n\n  if (props.swipable) {\n    useEvent(['touchstart', 'mousedown'], onSwipeStart, container)\n    useEvent(['touchmove', 'mousemove'], onSwipeMove, container)\n    useEvent(['touchcancel', 'mouseup', 'touchend', 'mouseleave'], resetSwipe, container)\n  }\n\n  return { swipeState }\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { computed, unref } from \"vue\";\nimport { f as isFunction_1, k as kebabCase_1 } from \"../../vendor.js\";\n\nconst useBem = (prefix, modifiers) => {\n  const modifiersList = computed(() => isFunction_1(modifiers) ? modifiers() : unref(modifiers));\n  const computedBemClassesObject = computed(() => {\n    return Object.entries(unref(modifiersList)).reduce((classesObj, [modifierName, value]) => {\n      if (value) {\n        classesObj[`${prefix}--${kebabCase_1(modifierName)}`] = true;\n      }\n\n      return classesObj;\n    }, {});\n  });\n  const computedBemClassesArray = computed(() => Object.keys(computedBemClassesObject.value));\n  const computedBemClassesString = computed(() => computedBemClassesArray.value.join(\" \"));\n  return new Proxy({}, {\n    ownKeys() {\n      return Reflect.ownKeys(computedBemClassesObject.value);\n    },\n\n    getOwnPropertyDescriptor(_, key) {\n      return Reflect.getOwnPropertyDescriptor(computedBemClassesObject.value, key);\n    },\n\n    get(_, key, receiver) {\n      switch (key) {\n        case \"asArray\":\n          return computedBemClassesArray;\n\n        case \"asString\":\n          return computedBemClassesString;\n\n        case \"asObject\":\n          return computedBemClassesObject;\n\n        default:\n          return Reflect.get(computedBemClassesObject.value, key, receiver);\n      }\n    }\n\n  });\n};\n\nexport { useBem as u };","map":{"version":3,"mappings":";;;AAgCa,eAAS,CACpBA,MADoB,EAEpBC,SAFoB,KAGjB;EAKG,sBAAgBC,SAAS,MAAMC,aAAWF,SAAXE,IAAwBF,WAAxBE,GAAsCC,MAAMH,SAAN,CAArD,CAAhB;EAEA,iCAA2BC,SAAS,MAAM;IACvC,cACJG,OADI,CACID,MAAME,aAAN,CADJ,EAEJC,MAFI,CAEG,CAACC,UAAD,EAAsC,CAACC,YAAD,EAAeC,KAAf,CAAtC,KAAgE;MACtE,IAAIA,KAAJ,EAAW;QAAEF,WAAW,GAAGR,WAAWW,YAAMF,YAANE,CAAkB,EAA3C,IAAkD,IAAlD;MAAuD;;MAC7D;IACT,CALK,EAKF,EALE;EAMR,CAPgC,CAA3B;EASN,MAAMC,0BAA0BV,SAAS,MAAMW,OAAOC,IAAP,CAAYC,yBAAyBL,KAArC,CAAf,CAAhC;EAEA,MAAMM,2BAA2Bd,SAAS,MAAMU,wBAAwBF,KAAxB,CAA8BO,IAA9B,CAAmC,GAAnC,CAAf,CAAjC;EAEO,WAAIC,KAAJ,CAAU,EAAV,EAAc;IACnBC,UAAW;MACF,eAAQA,OAAR,CAAgBJ,yBAAyBL,KAAzC;IACT,CAHmB;;IAInBU,yBAA0BC,CAA1B,EAA6BC,GAA7B,EAAkC;MAChC,OAAOC,QAAQH,wBAAR,CAAiCL,yBAAyBL,KAA1D,EAAiEY,GAAjE,CAAP;IACF,CANmB;;IAOnBE,IAAKH,CAAL,EAAQC,GAAR,EAAqBG,QAArB,EAAoC;MAC1B;QAAA,KACD,SADC;UAEG;;QAAA,KACJ,UADI;UAEA;;QAAA,KACJ,UADI;UAEA;;QAAA;UAEP,OAAOF,QAAQC,GAAR,CAAYT,yBAAyBL,KAArC,EAA4CY,GAA5C,EAAiDG,QAAjD,CAAP;MARI;IAUV;;EAlBmB,CAAd;AAoBT,CA3Ca","names":["prefix","modifiers","computed","isFunction","unref","entries","modifiersList","reduce","classesObj","modifierName","value","kebab","computedBemClassesArray","Object","keys","computedBemClassesObject","computedBemClassesString","join","Proxy","ownKeys","getOwnPropertyDescriptor","_","key","Reflect","get","receiver"],"sources":["../../../../src/composables/useBem.ts"],"sourcesContent":["import { computed, Ref, unref, ComputedRef } from 'vue'\n\nimport isFunction from 'lodash/isFunction.js'\nimport kebab from 'lodash/kebabCase.js'\n\nimport { __DEV__ } from '../utils/env'\n\ntype Key<Prefix extends string, ModifierKey extends string> = `${Prefix}--${ModifierKey | string}`\n\ntype ClassesObject<Key extends string> = Record<Key, boolean>\n\ntype ComputedClasses<Key extends string> = ClassesObject<Key> & {\n  // TODO: How to remove it from spread?\n  readonly asObject: ComputedRef<ClassesObject<Key>>\n  readonly asArray: ComputedRef<Key[]>\n  readonly asString: ComputedRef<string>\n}\n\n/**\n * @description creates BEM modifiers based on transferred prefix (base BEM class) & modifiers list.\n * camelCase modifiers names will be transformed to the kebab-case.\n * @param prefix string that classes start with (base BEM class).\n * @param modifiers list of options that will serve as state BEM modifiers.\n * @returns computed classes starting with \"prefix\" and ending with form state BEM modifier.\n * @example\n *  const result = useBem('va-component', computed(() => pick(props, ['success, noError'])))\n *  // if success & noError are `true`\n *  { ...result }: { 'va-component--success': true, va-component--no-error: true }\n *  result.asObject.value: { 'va-component--success': true, va-component--no-error: true }\n *  result.asArray.value: ['va-component--success', 'va-component--no-error']\n *  result.asString.value: 'va-component--success va-component--no-error'\n */\nexport const useBem = <ModifierKey extends string, Prefix extends string>(\n  prefix: Prefix,\n  modifiers: Record<ModifierKey, boolean> | Ref<Record<ModifierKey, boolean>> | (() => Record<ModifierKey, boolean>),\n) => {\n  if (__DEV__ && !prefix) {\n    console.warn('You must pass the @param \"prefix\" to the useBem hook!')\n  }\n\n  const modifiersList = computed(() => isFunction(modifiers) ? modifiers() : unref(modifiers))\n\n  const computedBemClassesObject = computed(() => {\n    return Object\n      .entries(unref(modifiersList))\n      .reduce((classesObj: Record<string, boolean>, [modifierName, value]) => {\n        if (value) { classesObj[`${prefix}--${kebab(modifierName)}`] = true }\n        return classesObj\n      }, {})\n  })\n\n  const computedBemClassesArray = computed(() => Object.keys(computedBemClassesObject.value))\n\n  const computedBemClassesString = computed(() => computedBemClassesArray.value.join(' '))\n\n  return new Proxy({}, {\n    ownKeys () {\n      return Reflect.ownKeys(computedBemClassesObject.value)\n    },\n    getOwnPropertyDescriptor (_, key) {\n      return Reflect.getOwnPropertyDescriptor(computedBemClassesObject.value, key)\n    },\n    get (_, key: string, receiver: any) {\n      switch (key) {\n        case 'asArray':\n          return computedBemClassesArray\n        case 'asString':\n          return computedBemClassesString\n        case 'asObject':\n          return computedBemClassesObject\n        default:\n          return Reflect.get(computedBemClassesObject.value, key, receiver)\n      }\n    },\n  }) as ComputedClasses<Key<Prefix, ModifierKey>>\n}\n"]},"metadata":{},"sourceType":"module"}
import { defineComponent, computed, ref, h, Fragment } from "vue";
import { u as useAlignProps, a as useAlign } from "../../composables/useAlign.js";

import { u as useColors } from "../../composables/useColors.js";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.js";





import { u as useTranslation } from "../../composables/useTranslation.js";
import { h as hasOwnProperty } from "../../utils/has-own-property.js";
var VaBreadcrumbs_vue_vue_type_style_index_0_lang = /* @__PURE__ */ (() => ":root{--va-breadcrumbs-display: flex;--va-breadcrumbs-width: 100%;--va-breadcrumbs-justify-content: center;--va-breadcrumbs-item-display: inline-flex;--va-breadcrumbs-separator-padding: var(--va-breadcrumbs-separator-py) var(--va-breadcrumbs-separator-px);--va-breadcrumbs-separator-py: 0;--va-breadcrumbs-separator-px: .5rem;--va-breadcrumbs-separator-display: inline-flex}.va-breadcrumbs{display:var(--va-breadcrumbs-display);width:var(--va-breadcrumbs-width);justify-content:var(--va-breadcrumbs-justify-content);font-family:var(--va-font-family)}.va-breadcrumbs__item{display:var(--va-breadcrumbs-item-display)}.va-breadcrumbs__separator{padding:var(--va-breadcrumbs-separator-padding);display:var(--va-breadcrumbs-separator-display)}\n")();
const _sfc_main = defineComponent({
  name: "VaBreadcrumbs",
  props: {
    ...useAlignProps,
    ...useComponentPresetProp,
    separator: { type: String, default: "/" },
    color: { type: String, default: "secondary" },
    activeColor: { type: String, default: null },
    separatorColor: { type: String, default: null }
  },
  setup(props, { slots }) {
    const { alignComputed } = useAlign(props);
    const { getColor } = useColors();
    const computedThemesSeparatorColor = computed(() => {
      return props.separatorColor ? getColor(props.separatorColor) : getColor(props.color);
    });
    const computedThemesActiveColor = computed(() => {
      return props.activeColor ? getColor(props.activeColor) : getColor(props.color);
    });
    const childNodeFilter = (result, node) => {
      const nodes = node && node.type === Fragment && node.children ? node.children : [node];
      return [
        ...result,
        ...nodes.filter((node2) => {
          var _a, _b;
          return !!((_b = (_a = node2 == null ? void 0 : node2.type) == null ? void 0 : _a.name) == null ? void 0 : _b.match(/VaBreadcrumbsItem$/));
        })
      ];
    };
    const createSeparatorComponent = () => {
      const separatorNode = slots.separator ? slots.separator() : [props.separator];
      return h("span", {
        ariaHidden: true,
        class: ["va-breadcrumbs__separator"],
        style: [{ color: computedThemesSeparatorColor.value }]
      }, separatorNode);
    };
    const isDisabledChild = (child) => {
      const childPropData = child == null ? void 0 : child.props;
      if (!childPropData || !hasOwnProperty(childPropData, "disabled")) {
        return false;
      }
      if (childPropData.disabled === "") {
        return true;
      }
      return Boolean(childPropData.disabled);
    };
    const isAllChildLinks = ref(true);
    const getChildren = () => {
      var _a;
      const childNodes = ((_a = slots == null ? void 0 : slots.default()) == null ? void 0 : _a.reduce(childNodeFilter, [])) || [];
      const childNodesLength = childNodes.length;
      const isLastIndexChildNodes = (index) => index === childNodesLength - 1;
      const isChildLink = (child) => {
        const childPropData = child == null ? void 0 : child.props;
        if (!childPropData || !hasOwnProperty(childPropData, "to")) {
          return false;
        }
        return !!(childPropData.to && !childPropData.disabled);
      };
      const createChildComponent = (child, index) => h("span", {
        class: "va-breadcrumbs__item",
        ariaCurrent: isLastIndexChildNodes(index) && isChildLink(child) ? "location" : false,
        style: {
          color: !isLastIndexChildNodes(index) && !isDisabledChild(child) ? computedThemesActiveColor.value : null
        }
      }, [child]);
      const children = [];
      if (childNodesLength) {
        childNodes.forEach((child, index) => {
          if (isAllChildLinks.value && !isChildLink(child)) {
            isAllChildLinks.value = false;
          }
          children.push(createChildComponent(child, index));
          if (!isLastIndexChildNodes(index)) {
            children.push(createSeparatorComponent());
          }
        });
      }
      return children;
    };
    const { t } = useTranslation();
    return () => h("div", {
      class: "va-breadcrumbs",
      style: alignComputed.value,
      role: isAllChildLinks.value ? "navigation" : void 0,
      ariaLabel: isAllChildLinks.value ? t("breadcrumbs") : void 0
    }, getChildren());
  }
});
export { _sfc_main as _ };

import './VaBreadcrumbs.css';
//# sourceMappingURL=VaBreadcrumbs.js.map

import { defineComponent, computed, openBlock, createElementBlock, normalizeClass, createElementVNode, normalizeStyle, renderSlot, createTextVNode, toDisplayString } from "vue";
import { g as generateUniqueId } from "../../utils/uuid.js";

import { u as useColors } from "../../composables/useColors.js";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.js";


import { u as useFormProps, a as useForm } from "../../composables/useForm.js";



import { _ as _export_sfc } from "../../../plugin-vue_export-helper.js";
var VaRadio_vue_vue_type_style_index_0_lang = /* @__PURE__ */ (() => ':root{--va-radio-display: inline-flex;--va-radio-cursor: pointer;--va-radio-position: relative;--va-radio-margin-top: 0;--va-radio-margin-right: .5rem;--va-radio-transition: .3s cubic-bezier(.25, .8, .5, 1);--va-radio-disabled-cursor: default;--va-radio-border-color: var(--va-background-border);--va-radio-icon-transition: .3s cubic-bezier(.25, .8, .5, 1);--va-radio-icon-width: 1.4rem;--va-radio-icon-height: 1.4rem;--va-radio-icon-border-radius: 100%;--va-radio-icon-border: var(--va-background-border) solid .125rem;--va-radio-dot-transition: .3s cubic-bezier(.25, .8, .5, 1);--va-radio-dot-top: 50%;--va-radio-dot-left: 50%;--va-radio-dot-right: 50%;--va-radio-dot-bottom: 50%;--va-radio-dot-border-radius: 100%;--va-radio-dot-background-color: inherit;--va-radio-dot-opacity: 0;--va-radio-background-transition: .3s cubic-bezier(.25, .8, .5, 1);--va-radio-background-top: -.35rem;--va-radio-background-left: -.35rem;--va-radio-background-right: -.35rem;--va-radio-background-bottom: -.35rem;--va-radio-background-background-color: var(--va-background-element);--va-radio-background-border-radius: 100%;--va-radio-background-z-index: 0;--va-radio-background-opacity: 0;--va-radio-text-display: inline-flex;--va-radio-text-margin-left: .5rem;--va-radio-text-margin-right: 0}.va-radio{display:var(--va-radio-display);align-items:center;cursor:var(--va-radio-cursor);position:var(--va-radio-position);margin-top:var(--va-radio-margin-top);margin-right:var(--va-radio-margin-right);transition:var(--va-radio-transition, var(--va-swing-transition));font-family:var(--va-font-family)}.va-radio+.va-radio{margin-top:.5rem}.va-radio--disabled{cursor:var(--va-radio-disabled-cursor)}.va-radio--readonly{cursor:default;pointer-events:none}.va-radio--readonly .va-radio--left-label,.va-radio--readonly .va-radio__text{cursor:initial;pointer-events:auto}.va-radio--left-label{flex-direction:row-reverse;display:inline-flex}.va-radio__input{position:absolute;width:1px;height:1px;margin:-1px;border:0;padding:0;white-space:nowrap;-webkit-clip-path:inset(100%);clip-path:inset(100%);clip:rect(0 0 0 0);overflow:hidden}.va-radio__icon{transition:var(--va-radio-icon-transition);display:flex;align-items:center;width:var(--va-radio-icon-width);height:var(--va-radio-icon-height);border-radius:var(--va-radio-icon-border-radius);position:relative;border:var(--va-radio-icon-border);box-sizing:border-box}.va-radio__input:disabled+.va-radio__icon{cursor:default;opacity:.4;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.va-radio__input:focus-visible+.va-radio__icon{outline:2px solid var(--va-focus)!important;border-radius:"inherit"}.va-radio__icon__dot{transition:var(--va-radio-dot-transition, var(--va-swing-transition));position:absolute;top:var(--va-radio-dot-top);left:var(--va-radio-dot-left);right:var(--va-radio-dot-right);bottom:var(--va-radio-dot-bottom);border-radius:var(--va-radio-dot-border-radius);background-color:var(--va-radio-dot-background-color);opacity:var(--va-radio-dot-opacity)}.va-radio__input:checked+.va-radio__icon .va-radio__icon__dot{opacity:1;top:.25rem;left:.25rem;right:.25rem;bottom:.25rem}.va-radio__icon__background{transition:var(--va-radio-background-transition, var(--va-swing-transition));position:absolute;top:var(--va-radio-background-top);left:var(--va-radio-background-left);right:var(--va-radio-background-right);bottom:var(--va-radio-background-bottom);background-color:var(--va-radio-background-background-color);border-radius:var(--va-radio-background-border-radius);z-index:var(--va-radio-background-z-index);opacity:var(--va-radio-background-opacity)}.va-radio:hover .va-radio__icon__background{opacity:.2}.va-radio--disabled:hover .va-radio__icon__background{opacity:0}.va-radio__text{display:var(--va-radio-text-display);margin-left:var(--va-radio-text-margin-left);margin-right:var(--va-radio-text-margin-right)}.va-radio--disabled .va-radio__text{cursor:default;opacity:.4;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.va-radio--left-label .va-radio__text{margin-left:0;margin-right:.5rem}\n')();
const _sfc_main = defineComponent({
  name: "VaRadio",
  emits: ["update:modelValue", "focus"],
  props: {
    ...useFormProps,
    ...useComponentPresetProp,
    modelValue: { type: [Boolean, Array, String, Object, Number], default: null },
    option: { type: [String, Boolean, Object, Number], default: null },
    name: { type: String, default: "" },
    label: { type: String, default: "" },
    leftLabel: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    tabindex: { type: Number, default: 0 }
  },
  setup(props, { emit }) {
    const { getColor } = useColors();
    const isActive = computed(() => props.modelValue === props.option);
    const { computedClasses } = useForm("va-radio", props);
    const computedClass = computed(() => ({
      "va-radio--left-label": props.leftLabel,
      ...computedClasses
    }));
    const iconBackgroundComputedStyles = computed(() => ({
      backgroundColor: getColor(props.color)
    }));
    const iconDotComputedStyles = computed(() => {
      if (!isActive.value) {
        return;
      }
      return {
        borderColor: getColor(props.color),
        backgroundColor: getColor(props.color)
      };
    });
    const iconComputedStyles = computed(() => {
      if (!isActive.value) {
        return;
      }
      return { borderColor: getColor(props.color) };
    });
    const computedLabel = computed(() => props.label || props.option);
    const onClick = (e) => {
      if (props.readonly || props.disabled) {
        return;
      }
      emit("update:modelValue", props.option, e);
    };
    const onFocus = (e) => emit("focus", e);
    return {
      computedClass,
      isActive,
      iconBackgroundComputedStyles,
      iconDotComputedStyles,
      iconComputedStyles,
      computedLabel,
      onClick,
      onFocus,
      computedName: computed(() => props.name || generateUniqueId()),
      tabIndexComputed: computed(() => props.disabled ? -1 : props.tabindex)
    };
  }
});
const _hoisted_1 = ["checked", "disabled", "readonly", "name", "value", "aria-checked", "tabindex"];
const _hoisted_2 = { class: "va-radio__text" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("label", {
    class: normalizeClass(["va-radio", _ctx.computedClass])
  }, [
    createElementVNode("input", {
      class: "va-radio__input",
      type: "radio",
      checked: _ctx.isActive,
      disabled: _ctx.$props.disabled,
      readonly: _ctx.$props.readonly,
      name: _ctx.computedName,
      value: _ctx.computedLabel,
      "aria-checked": _ctx.isActive,
      tabindex: _ctx.tabIndexComputed,
      onChange: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args)),
      onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.onFocus && _ctx.onFocus(...args))
    }, null, 40, _hoisted_1),
    createElementVNode("span", {
      "aria-hidden": "true",
      class: "va-radio__icon",
      style: normalizeStyle(_ctx.iconComputedStyles)
    }, [
      createElementVNode("span", {
        class: "va-radio__icon__background",
        style: normalizeStyle(_ctx.iconBackgroundComputedStyles)
      }, null, 4),
      createElementVNode("span", {
        class: "va-radio__icon__dot",
        style: normalizeStyle(_ctx.iconDotComputedStyles)
      }, null, 4)
    ], 4),
    createElementVNode("span", _hoisted_2, [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(_ctx.computedLabel), 1)
      ])
    ])
  ], 2);
}
var _VaRadio = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { _VaRadio as _ };

import './VaRadio.css';
//# sourceMappingURL=VaRadio.js.map

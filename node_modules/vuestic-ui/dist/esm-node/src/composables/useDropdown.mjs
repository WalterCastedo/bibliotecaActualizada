import { computed, unref, watchPostEffect } from "vue";
import { m as mapObject } from "../utils/map-object.mjs";
import { u as useDomRect } from "./useDomRect.mjs";
import { u as useDocument } from "./useDocument.mjs";
const placementsPositions = ["top", "bottom", "left", "right"].reduce((acc, position) => [...acc, position, `${position}-start`, `${position}-end`, `${position}-center`], ["auto"]);
const coordsToCss = ({ x, y }) => ({ left: `${x}px`, top: `${y}px` });
const parsePlacement = (placement) => {
  let [position, align] = placement.split("-");
  if (position === "auto") {
    position = "bottom";
  }
  return { position, align: align || "center" };
};
const parseOffset = (offset) => {
  return Array.isArray(offset) ? { main: offset[0], cross: offset[1] } : { main: offset, cross: 0 };
};
const calculateContentAlignment = (align, anchorStart, anchorSize, contentSize) => {
  if (align === "start") {
    return anchorStart;
  }
  if (align === "end") {
    return anchorStart + anchorSize - contentSize;
  }
  return anchorStart + (anchorSize - contentSize) / 2;
};
const calculateContentCoords = (placement, anchor, content) => {
  const { position, align } = parsePlacement(placement);
  const alignmentX = calculateContentAlignment(align, anchor.left, anchor.width, content.width);
  const alignmentY = calculateContentAlignment(align, anchor.top, anchor.height, content.height);
  switch (position) {
    case "top":
      return { x: alignmentX, y: anchor.top - content.height };
    case "left":
      return { y: alignmentY, x: anchor.left - content.width };
    case "right":
      return { y: alignmentY, x: anchor.right };
    case "bottom":
    default:
      return { x: alignmentX, y: anchor.bottom };
  }
};
const calculateOffsetCoords = (placement, offset) => {
  const { position } = parsePlacement(placement);
  const { main, cross } = parseOffset(offset);
  switch (position) {
    case "left":
      return { y: cross, x: -main };
    case "right":
      return { y: cross, x: main };
    case "top":
      return { y: -main, x: cross };
    case "bottom":
    default:
      return { y: main, x: cross };
  }
};
const calculateContentOverflow = (coords, content, viewport) => {
  const xMax = viewport.right;
  const yMax = viewport.bottom;
  const xMin = viewport.left;
  const yMin = viewport.top;
  return {
    top: Math.max(yMin - coords.y, 0),
    bottom: Math.max(coords.y + content.height - yMax, 0),
    left: Math.max(xMin - coords.x, 0),
    right: Math.max(coords.x + content.width - xMax, 0)
  };
};
const clamp = (min, v, max) => Math.max(Math.min(v, max), min);
const calculateClipToEdge = (coords, offsetCoords, content, anchor, viewport) => {
  const { top, bottom, left, right } = calculateContentOverflow(coords, content, viewport);
  const x = coords.x - right + left;
  const y = coords.y - bottom + top;
  const { x: offsetX, y: offsetY } = offsetCoords;
  return {
    x: clamp(anchor.left + offsetX - content.width, x, anchor.right + offsetX),
    y: clamp(anchor.top + offsetY - content.height, y, anchor.bottom + offsetY)
  };
};
const getAutoPlacement = (placement, coords, content, viewport) => {
  const { position } = parsePlacement(placement);
  const overflow = calculateContentOverflow(coords, content, viewport);
  const newPlacements = {
    top: "bottom",
    bottom: "top",
    right: "left",
    left: "right"
  };
  if (!overflow[position]) {
    return placement;
  }
  const newPlacement = newPlacements[position];
  if (newPlacement === "bottom" || newPlacement === "top") {
    if (overflow.left) {
      return [newPlacement, "start"].join("-");
    }
    if (overflow.right) {
      return [newPlacement, "end"].join("-");
    }
  }
  if (newPlacement === "left" || newPlacement === "right") {
    if (overflow.top) {
      return [newPlacement, "start"].join("-");
    }
    if (overflow.bottom) {
      return [newPlacement, "end"].join("-");
    }
  }
  return newPlacement;
};
const findFirstRelativeParent = (el) => {
  while (el) {
    const positionValue = window.getComputedStyle(el).getPropertyValue("position") || el.style.position;
    if (positionValue === "relative") {
      return el;
    }
    el = el.parentElement;
  }
  return document.body;
};
const useDropdown = (anchorRef, contentRef, options) => {
  const documentRef = useDocument();
  const rootRef = computed(() => {
    if (!documentRef.value) {
      return void 0;
    }
    const { root } = unref(options);
    if (root) {
      let el;
      if (typeof root === "string") {
        el = documentRef.value.querySelector(root);
      } else {
        el = root;
      }
      if (!el) {
        return documentRef.value.body;
      }
      return findFirstRelativeParent(el);
    }
    return documentRef.value.body;
  });
  const { domRect: anchorDomRect } = useDomRect(anchorRef);
  const { domRect: contentDomRect } = useDomRect(contentRef);
  const css = {
    width: "max-content",
    position: "absolute"
  };
  watchPostEffect(() => {
    var _a, _b;
    if (!rootRef.value || !anchorDomRect.value || !contentDomRect.value) {
      return;
    }
    const { placement, offset, keepAnchorWidth, autoPlacement, stickToEdges } = unref(options);
    let coords = calculateContentCoords(placement, anchorDomRect.value, contentDomRect.value);
    let offsetCoords = { x: 0, y: 0 };
    if (offset) {
      offsetCoords = calculateOffsetCoords(placement, offset);
      coords = mapObject(coords, (c, key) => c + offsetCoords[key]);
    }
    const rootRect = rootRef.value.getBoundingClientRect();
    const viewportRect = (_b = (_a = unref(options).viewport) == null ? void 0 : _a.getBoundingClientRect()) != null ? _b : rootRect;
    if (autoPlacement) {
      const newPlacement = getAutoPlacement(placement, coords, contentDomRect.value, viewportRect);
      if (newPlacement !== placement) {
        coords = calculateContentCoords(newPlacement, anchorDomRect.value, contentDomRect.value);
        if (offset) {
          offsetCoords = calculateOffsetCoords(newPlacement, offset);
          coords = mapObject(coords, (c, key) => c + offsetCoords[key]);
        }
      }
    }
    if (stickToEdges) {
      coords = calculateClipToEdge(coords, offsetCoords, contentDomRect.value, anchorDomRect.value, viewportRect);
    }
    coords.x -= rootRect.x;
    coords.y -= rootRect.y;
    if (contentRef.value) {
      let widthCss = {};
      if (keepAnchorWidth) {
        const { width } = anchorDomRect.value;
        widthCss = { width: `${width}px`, maxWidth: `${width}px` };
      }
      Object.assign(contentRef.value.style, {
        ...css,
        ...coordsToCss(coords),
        ...widthCss
      });
    }
  });
  return {
    anchorDomRect,
    contentDomRect
  };
};
export { placementsPositions as p, useDropdown as u };
//# sourceMappingURL=useDropdown.mjs.map

import { defineComponent, shallowRef, computed, resolveComponent, openBlock, createBlock, normalizeClass, withCtx, createElementVNode, normalizeStyle, withModifiers, mergeProps, toHandlers, withDirectives, createVNode, vShow, createElementBlock, renderSlot, createTextVNode, toDisplayString, createCommentVNode } from "vue";
import { g as generateUniqueId } from "../../utils/uuid.mjs";

import { u as useColors } from "../../composables/useColors.mjs";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.mjs";




import { u as useKeyboardOnlyFocus } from "../../composables/useKeyboardOnlyFocus.mjs";

import { u as useSelectableEmits, a as useSelectableProps, b as useSelectable } from "../../composables/useSelectable.mjs";
import { u as useTextColor } from "../../composables/useTextColor.mjs";

import { V as VaIcon } from "../va-icon/index.mjs";
import { _ as _export_sfc } from "../../../plugin-vue_export-helper.mjs";
import { V as VaMessageListWrapper } from "../va-input/components/VaMessageListWrapper.mjs";
var VaCheckbox_vue_vue_type_style_index_0_lang = /* @__PURE__ */ (() => ":root{--va-checkbox-display: inline-block;--va-checkbox-input-padding: 0;--va-checkbox-input-cursor: pointer;--va-checkbox-disabled-cursor: default;--va-checkbox-readonly-cursor: initial;--va-checkbox-label-display: inline-block;--va-checkbox-font-size: 15px;--va-checkbox-line-height: 20px;--va-checkbox-square-width: 1.35rem;--va-checkbox-square-min-width: 1.35rem;--va-checkbox-square-height: 1.35rem;--va-checkbox-square-background-color: var(--va-background-element);--va-checkbox-square-border: solid .125rem var(--va-background-border);--va-checkbox-square-border-radius: .25rem}.va-checkbox{display:var(--va-checkbox-display);max-width:-webkit-fit-content;max-width:-moz-fit-content;max-width:fit-content;font-family:var(--va-font-family)}.va-checkbox__input-container{align-items:center;display:flex;padding:var(--va-checkbox-input-padding);cursor:var(--va-checkbox-input-cursor);font-size:var(--va-checkbox-font-size);line-height:var(--va-checkbox-line-height)}.va-checkbox--disabled .va-checkbox__input-container{cursor:default;opacity:.4;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:var(--va-checkbox-disabled-cursor)}.va-checkbox--readonly .va-checkbox__input-container{cursor:var(--va-checkbox-readonly-cursor)}.va-checkbox--left-label .va-checkbox__input-container{flex-direction:row-reverse}.va-checkbox .va-checkbox__square{display:flex;justify-content:center;align-items:center;width:var(--va-checkbox-square-width);min-width:var(--va-checkbox-square-min-width);height:var(--va-checkbox-square-height);position:relative;background-color:var(--va-checkbox-square-background-color);border:var(--va-checkbox-square-border, var(--va-control-border));border-radius:var(--va-checkbox-square-border-radius)}.va-checkbox--on-keyboard-focus.va-checkbox .va-checkbox__square{transition:all,.6s,ease-in;outline:2px solid var(--va-focus)}.va-checkbox__input{position:absolute;width:1px;height:1px;margin:-1px;border:0;padding:0;white-space:nowrap;-webkit-clip-path:inset(100%);clip-path:inset(100%);clip:rect(0 0 0 0);overflow:hidden}.va-checkbox__label{display:var(--va-checkbox-label-display);position:relative}.va-checkbox__icon{pointer-events:none;position:absolute}.va-checkbox--selected .va-checkbox__icon{color:var(--va-checkbox-selected-icon-color)}.va-checkbox--indeterminate .va-checkbox__icon{color:var(--va-checkbox-indeterminate-icon-color)}\n")();
const VaCheckboxValueType = [Boolean, Array, String, Object];
const _sfc_main = defineComponent({
  name: "VaCheckbox",
  components: { VaMessageListWrapper, VaIcon },
  emits: useSelectableEmits,
  props: {
    ...useSelectableProps,
    ...useComponentPresetProp,
    modelValue: { type: VaCheckboxValueType, default: false },
    color: { type: String, default: "primary" },
    checkedIcon: { type: String, default: "va-check" },
    indeterminate: { type: Boolean, default: false },
    indeterminateValue: { type: VaCheckboxValueType, default: null },
    indeterminateIcon: { type: String, default: "remove" },
    id: { type: String, default: "" },
    name: { type: String, default: "" },
    ariaLabel: { type: String, default: void 0 }
  },
  setup(props, { emit }) {
    const elements = {
      container: shallowRef(),
      input: shallowRef(),
      label: shallowRef()
    };
    const {
      isChecked,
      computedError,
      isIndeterminate,
      computedErrorMessages,
      validationAriaAttributes,
      toggleSelection,
      onBlur,
      onFocus
    } = useSelectable(props, emit, elements);
    const { getColor } = useColors();
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const { textColorComputed } = useTextColor();
    const isActive = computed(() => isChecked.value || isIndeterminate.value);
    const computedClass = computed(() => ({
      "va-checkbox--selected": isChecked.value,
      "va-checkbox--readonly": props.readonly,
      "va-checkbox--disabled": props.disabled,
      "va-checkbox--indeterminate": props.indeterminate,
      "va-checkbox--error": computedError.value,
      "va-checkbox--left-label": props.leftLabel,
      "va-checkbox--on-keyboard-focus": hasKeyboardFocus.value
    }));
    const labelStyle = computed(() => {
      return {
        color: computedError.value ? getColor("danger") : "",
        padding: !props.label ? "" : props.leftLabel ? "0 0.5rem 0 0" : "0 0 0 0.5rem"
      };
    });
    const inputStyle = computed(() => {
      const style = {
        background: isActive.value ? getColor(props.color) : "",
        borderColor: isActive.value ? getColor(props.color) : ""
      };
      if (computedError.value) {
        style.borderColor = getColor("danger");
      }
      return style;
    });
    const computedIconName = computed(() => props.indeterminate && isIndeterminate.value ? props.indeterminateIcon : props.checkedIcon);
    const uniqueId = computed(generateUniqueId);
    const computedId = computed(() => props.id || uniqueId.value);
    const computedName = computed(() => props.name || uniqueId.value);
    const inputAttributesComputed = computed(() => ({
      name: computedName.value,
      disabled: props.disabled,
      readonly: props.readonly,
      tabindex: props.disabled ? -1 : 0,
      ariaLabel: props.ariaLabel,
      ariaDisabled: props.disabled,
      ariaReadOnly: props.readonly,
      ariaChecked: isActive.value,
      ...validationAriaAttributes.value
    }));
    return {
      isActive,
      computedClass,
      labelStyle,
      inputStyle,
      computedIconName,
      textColorComputed,
      computedError,
      computedErrorMessages,
      keyboardFocusListeners,
      toggleSelection,
      onBlur,
      onFocus,
      inputAttributesComputed,
      computedId,
      computedName
    };
  }
});
const _hoisted_1 = ["id", "indeterminate", "value", "checked"];
const _hoisted_2 = ["for"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_VaMessageListWrapper = resolveComponent("VaMessageListWrapper");
  return openBlock(), createBlock(_component_VaMessageListWrapper, {
    class: normalizeClass(["va-checkbox", _ctx.computedClass]),
    disabled: _ctx.disabled,
    success: _ctx.success,
    messages: _ctx.messages,
    error: _ctx.computedError,
    "error-messages": _ctx.computedErrorMessages,
    "error-count": _ctx.errorCount
  }, {
    default: withCtx(() => [
      createElementVNode("div", {
        ref: "container",
        class: "va-checkbox__input-container",
        onClick: _cache[6] || (_cache[6] = (...args) => _ctx.toggleSelection && _ctx.toggleSelection(...args)),
        onBlur: _cache[7] || (_cache[7] = (...args) => _ctx.onBlur && _ctx.onBlur(...args))
      }, [
        createElementVNode("div", {
          class: "va-checkbox__square",
          style: normalizeStyle(_ctx.inputStyle),
          onSelectstart: _cache[4] || (_cache[4] = withModifiers(() => {
          }, ["prevent"]))
        }, [
          createElementVNode("input", mergeProps({
            ref: "input",
            type: "checkbox",
            class: "va-checkbox__input",
            id: _ctx.computedId,
            indeterminate: _ctx.indeterminate,
            value: _ctx.label,
            checked: _ctx.isActive
          }, _ctx.inputAttributesComputed, toHandlers(_ctx.keyboardFocusListeners), {
            onFocus: _cache[0] || (_cache[0] = (...args) => _ctx.onFocus && _ctx.onFocus(...args)),
            onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.onBlur && _ctx.onBlur(...args)),
            onClick: _cache[2] || (_cache[2] = withModifiers(() => {
            }, ["stop", "prevent"])),
            onKeypress: _cache[3] || (_cache[3] = withModifiers((...args) => _ctx.toggleSelection && _ctx.toggleSelection(...args), ["prevent"]))
          }), null, 16, _hoisted_1),
          withDirectives(createVNode(_component_va_icon, {
            class: "va-checkbox__icon",
            size: "20px",
            name: _ctx.computedIconName,
            color: _ctx.textColorComputed
          }, null, 8, ["name", "color"]), [
            [vShow, _ctx.isActive]
          ])
        ], 36),
        _ctx.label || _ctx.$slots.label ? (openBlock(), createElementBlock("label", {
          key: 0,
          ref: "label",
          class: "va-checkbox__label",
          for: _ctx.computedId,
          style: normalizeStyle(_ctx.labelStyle),
          onBlur: _cache[5] || (_cache[5] = (...args) => _ctx.onBlur && _ctx.onBlur(...args))
        }, [
          renderSlot(_ctx.$slots, "label", {}, () => [
            createTextVNode(toDisplayString(_ctx.label), 1)
          ])
        ], 44, _hoisted_2)) : createCommentVNode("", true)
      ], 544)
    ]),
    _: 3
  }, 8, ["class", "disabled", "success", "messages", "error", "error-messages", "error-count"]);
}
var _VaCheckbox = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { _VaCheckbox as _ };
//# sourceMappingURL=VaCheckbox.mjs.map

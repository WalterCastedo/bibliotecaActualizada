import { defineComponent, shallowRef, ref, computed, onMounted, resolveComponent, openBlock, createBlock, Transition, withCtx, withDirectives, createElementVNode, normalizeClass, normalizeStyle, createElementBlock, toDisplayString, createCommentVNode, vShow, createVNode, withModifiers, withKeys } from "vue";

import { u as useColors } from "../../composables/useColors.mjs";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.mjs";





import { u as useTextColor } from "../../composables/useTextColor.mjs";
import { u as useTimer } from "../../composables/useTimer.mjs";
import { u as useTranslation } from "../../composables/useTranslation.mjs";
import { V as VaIcon } from "../va-icon/VaIcon.mjs";
import { _ as _export_sfc } from "../../../plugin-vue_export-helper.mjs";
var VaToast_vue_vue_type_style_index_0_lang = /* @__PURE__ */ (() => ":root{--va-toast-display: flex;--va-toast-width: 330px;--va-toast-padding: 14px 26px 14px 13px;--va-toast-border-radius: 8px;--va-toast-border: 1px solid var(--va-background-secondary);--va-toast-background-color: var(--va-background-secondary);--va-toast-border-color: var(--va-background-secondary);--va-toast-box-shadow: 0 2px 12px 0 var(--va-shadow);--va-toast-transition: opacity .3s, transform .3s, left .3s, right .3s, top .4s, bottom .3s;--va-toast-z-index: calc(var(--va-z-index-teleport-overlay) + 100);--va-toast-group-margin-left: 13px;--va-toast-group-margin-right: 8px;--va-toast-title-font-weight: bold;--va-toast-title-font-size: 1rem;--va-toast-title-color: #303133;--va-toast-title-margin: 0 0 6px;--va-toast-content-font-size: 1rem;--va-toast-content-line-height: 1.3125;--va-toast-content-padding-right: 20px;--va-toast-icon-height: 24px;--va-toast-icon-width: 24px;--va-toast-icon-font-size: 24px;--va-toast-close-icon-top: 18px;--va-toast-close-icon-right: 15px;--va-toast-close-icon-font-size: 1rem;--va-toast-hover-color: #909399}.va-toast{position:fixed;box-sizing:border-box;width:var(--va-toast-width);padding:var(--va-toast-padding);display:flex;align-items:center;border-radius:var(--va-toast-border-radius);border:1px solid var(--va-toast-border-color);background-color:var(--va-toast-background-color);box-shadow:var(--va-toast-box-shadow);transition:var(--va-toast-transition);overflow:hidden;z-index:var(--va-toast-z-index);font-family:var(--va-font-family)}.va-toast--multiline{min-height:70px}.va-toast--right{right:16px}.va-toast--left{left:16px}.va-toast__group{margin-left:var(--va-toast-group-margin-left);margin-right:var(--va-toast-group-margin-right)}.va-toast__title{font-weight:var(--va-toast-title-font-weight);font-size:var(--va-toast-title-font-size);color:var(--va-toast-title-color);margin:var(--va-toast-title-margin)}.va-toast__content{font-size:var(--va-toast-content-font-size);line-height:var(--va-toast-content-line-height);padding-right:var(--va-toast-content-padding-right)}.va-toast__content p,.va-toast__content div{margin:0}.va-toast__icon{height:var(--va-toast-icon-height);width:var(--va-toast-icon-width);font-size:var(--va-toast-icon-font-size)}.va-toast__close-icon{position:absolute;top:50%;right:var(--va-toast-close-icon-right);cursor:pointer;transform:translateY(-50%);font-size:var(--va-toast-close-icon-font-siz);opacity:.7}.va-toast__close-icon:hover{opacity:1}.va-toast-fade-enter.right{right:0;transform:translate(100%)}.va-toast-fade-enter.left{left:0;transform:translate(-100%)}.va-toast-fade-leave-active{opacity:0}\n")();
const VaToastRenderer = defineComponent({
  name: "VaToastRenderer",
  props: {
    render: { type: Function, required: true }
  },
  setup: (props) => () => props.render()
});
const _sfc_main = defineComponent({
  name: "VaToast",
  components: { VaIcon, VaToastRenderer },
  emits: ["on-click", "on-close"],
  props: {
    ...useComponentPresetProp,
    title: { type: String, default: "" },
    offsetY: { type: Number, default: 16 },
    offsetX: { type: Number, default: 16 },
    message: { type: [String, Function], default: "" },
    dangerouslyUseHtmlString: { type: Boolean, default: false },
    icon: { type: String, default: "close" },
    customClass: { type: String, default: "" },
    duration: { type: Number, default: 5e3 },
    color: { type: String, default: "" },
    closeable: { type: Boolean, default: true },
    onClose: { type: Function },
    onClick: { type: Function },
    multiLine: { type: Boolean, default: false },
    position: {
      type: String,
      default: "top-right",
      validator: (value) => ["top-right", "top-left", "bottom-right", "bottom-left"].includes(value)
    },
    render: { type: Function }
  },
  setup(props, { emit }) {
    const rootElement = shallowRef();
    const { getColor } = useColors();
    const { textColorComputed } = useTextColor();
    const visible = ref(false);
    const positionX = computed(() => {
      return props.position.includes("right") ? "right" : "left";
    });
    const positionY = computed(() => {
      return props.position.includes("top") ? "top" : "bottom";
    });
    const toastClasses = computed(() => [
      props.customClass,
      props.multiLine ? "va-toast--multiline" : ""
    ]);
    const toastStyles = computed(() => ({
      [positionY.value]: `${props.offsetY}px`,
      [positionX.value]: `${props.offsetX}px`,
      backgroundColor: getColor(props.color),
      color: textColorComputed.value
    }));
    const computedMessage = computed(() => typeof props.message === "function" ? props.message() : props.message);
    const destroyElement = () => {
      var _a, _b;
      (_a = rootElement.value) == null ? void 0 : _a.removeEventListener("transitionend", destroyElement);
      (_b = rootElement.value) == null ? void 0 : _b.remove();
    };
    const onToastClick = () => {
      if (typeof props.onClick === "function") {
        props.onClick();
      } else {
        emit("on-click");
      }
    };
    const onToastClose = () => {
      var _a;
      visible.value = false;
      (_a = rootElement.value) == null ? void 0 : _a.addEventListener("transitionend", destroyElement);
      if (typeof props.onClose === "function") {
        props.onClose();
      } else {
        emit("on-close");
      }
    };
    const timer = useTimer();
    const clearTimer = timer.clear;
    const startTimer = () => {
      if (props.duration > 0) {
        timer.start(() => visible.value && onToastClose(), props.duration);
      }
    };
    onMounted(() => {
      visible.value = true;
      startTimer();
    });
    return {
      ...useTranslation(),
      visible,
      toastClasses,
      toastStyles,
      computedMessage,
      onToastClick,
      onToastClose,
      startTimer,
      clearTimer
    };
  }
});
const _hoisted_1 = ["role"];
const _hoisted_2 = { class: "va-toast__group" };
const _hoisted_3 = ["textContent"];
const _hoisted_4 = { class: "va-toast__content" };
const _hoisted_5 = ["innerHTML"];
const _hoisted_6 = ["textContent"];
const _hoisted_7 = {
  key: 1,
  class: "va-toast__content"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaToastRenderer = resolveComponent("VaToastRenderer");
  const _component_va_icon = resolveComponent("va-icon");
  return openBlock(), createBlock(Transition, { name: "va-toast-fade" }, {
    default: withCtx(() => [
      withDirectives(createElementVNode("div", {
        ref: "rootElement",
        role: _ctx.$props.closeable ? "alertdialog" : "alert",
        class: normalizeClass(["va-toast", _ctx.toastClasses]),
        style: normalizeStyle(_ctx.toastStyles),
        onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.clearTimer && _ctx.clearTimer(...args)),
        onMouseleave: _cache[1] || (_cache[1] = (...args) => _ctx.startTimer && _ctx.startTimer(...args)),
        onClick: _cache[2] || (_cache[2] = (...args) => _ctx.onToastClick && _ctx.onToastClick(...args))
      }, [
        createElementVNode("div", _hoisted_2, [
          _ctx.$props.title ? (openBlock(), createElementBlock("h2", {
            key: 0,
            class: "va-toast__title",
            textContent: toDisplayString(_ctx.$props.title)
          }, null, 8, _hoisted_3)) : createCommentVNode("", true),
          withDirectives(createElementVNode("div", _hoisted_4, [
            _ctx.$props.dangerouslyUseHtmlString ? (openBlock(), createElementBlock("div", {
              key: 0,
              innerHTML: _ctx.computedMessage
            }, null, 8, _hoisted_5)) : (openBlock(), createElementBlock("p", {
              key: 1,
              textContent: toDisplayString(_ctx.computedMessage)
            }, null, 8, _hoisted_6))
          ], 512), [
            [vShow, _ctx.$props.message]
          ]),
          _ctx.$props.render ? (openBlock(), createElementBlock("div", _hoisted_7, [
            createVNode(_component_VaToastRenderer, {
              render: _ctx.$props.render
            }, null, 8, ["render"])
          ])) : createCommentVNode("", true),
          _ctx.$props.closeable ? (openBlock(), createBlock(_component_va_icon, {
            key: 2,
            class: "va-toast__close-icon",
            role: "button",
            "aria-label": _ctx.t("closeToast"),
            tabindex: "0",
            size: "small",
            name: _ctx.$props.icon,
            onClick: withModifiers(_ctx.onToastClose, ["stop"]),
            onKeydown: withKeys(withModifiers(_ctx.onToastClose, ["stop"]), ["enter"])
          }, null, 8, ["aria-label", "name", "onClick", "onKeydown"])) : createCommentVNode("", true)
        ])
      ], 46, _hoisted_1), [
        [vShow, _ctx.visible]
      ])
    ]),
    _: 1
  });
}
var _VaToast = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { _VaToast as _ };
//# sourceMappingURL=VaToast.mjs.map

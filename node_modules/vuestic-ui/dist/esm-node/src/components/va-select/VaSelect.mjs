import { defineComponent, shallowRef, computed, ref, watch, nextTick, resolveComponent, openBlock, createBlock, mergeProps, withCtx, createVNode, createSlots, withModifiers, withKeys, createCommentVNode, renderSlot, createElementBlock, toDisplayString, normalizeProps, createTextVNode, normalizeStyle, guardReactiveProps } from "vue";

import { a as useClearableEmits, u as useClearableProps, b as useClearable } from "../../composables/useClearable.mjs";
import { u as useColors } from "../../composables/useColors.mjs";
import { u as useComponentPresetProp } from "../../composables/useComponentPreset.mjs";


import { u as useFocusDeep } from "../../composables/useFocusDeep.mjs";
import { u as useFormProps } from "../../composables/useForm.mjs";


import { u as useLoadingProps } from "../../composables/useLoading.mjs";
import { u as useMaxSelectionsProps, a as useMaxSelections } from "../../composables/useMaxSelections.mjs";

import { a as useValidationEmits, u as useValidationProps, b as useValidation } from "../../composables/useValidation.mjs";
import { u as useSelectableListProps, a as useSelectableList } from "../../composables/useSelectableList.mjs";
import { u as useTranslation } from "../../composables/useTranslation.mjs";
import { e as extractComponentProps } from "../../utils/component-options/extract-component-options.mjs";
import { f as filterComponentProps } from "../../utils/component-options/filter-props.mjs";
import { V as VaDropdown } from "../va-dropdown/index.mjs";
import { V as VaIcon } from "../va-icon/index.mjs";
import { V as VaInput } from "../va-input/index.mjs";
import { V as VaSelectOptionList } from "./components/VaSelectOptionList/index.mjs";
import { _ as _export_sfc } from "../../../plugin-vue_export-helper.mjs";
import { V as VaDropdownContent } from "../va-dropdown/components/VaDropdownContent/index.mjs";
import { V as VaInputWrapper } from "../va-input/components/VaInputWrapper/VaInputWrapper.mjs";
var VaSelect_vue_vue_type_style_index_0_lang = /* @__PURE__ */ (() => ":root{--va-select-cursor: pointer;--va-select-dropdown-border-radius: 4px;--va-select-dropdown-background: var(--va-background-secondary);--va-select-box-shadow: 0 4px 8px rgba(59, 63, 73, .15);--va-select-min-width: var(--va-form-element-min-width)}.va-select{min-width:var(--va-select-min-width)}.va-select .va-input-wrapper__text{line-height:normal;flex-wrap:wrap}.va-select-anchor__input{cursor:var(--va-select-cursor);flex:1}.va-select-anchor__placeholder{color:var(--va-input-placeholder-text-color);line-height:normal;white-space:nowrap!important;overflow:hidden!important;text-overflow:ellipsis!important;flex:1}.va-select-dropdown__content{overflow:hidden;border-bottom-right-radius:var(--va-select-dropdown-border-radius);border-bottom-left-radius:var(--va-select-dropdown-border-radius);border-top-right-radius:0;border-top-left-radius:0;box-shadow:var(--va-select-box-shadow);padding:0}.va-select-dropdown__content-search-input{min-width:auto;width:100%}.va-select-dropdown__options-wrapper{background:var(--va-select-dropdown-background);overflow-y:auto;scrollbar-color:var(--va-background-element) transparent;scrollbar-width:thin}.va-select-dropdown__options-wrapper::-webkit-scrollbar{width:4px;height:4px}.va-select-dropdown__options-wrapper::-webkit-scrollbar-track{box-shadow:none;border-radius:10px}.va-select-dropdown__options-wrapper::-webkit-scrollbar-thumb{background:var(--va-background-element);opacity:.3;border-radius:2px}\n")();
const VaDropdownProps = extractComponentProps(VaDropdown, ["keyboardNavigation", "offset", "stateful", "keepAnchorWidth", "closeOnContentClick", "innerAnchorSelector", "modelValue"]);
const _sfc_main = defineComponent({
  name: "VaSelect",
  components: {
    VaSelectOptionList,
    VaIcon,
    VaDropdown,
    VaDropdownContent,
    VaInput,
    VaInputWrapper
  },
  emits: [
    "update:modelValue",
    "update-search",
    "create-new",
    "scroll-bottom",
    ...useValidationEmits,
    ...useClearableEmits
  ],
  props: {
    ...VaDropdownProps,
    ...useSelectableListProps,
    ...useValidationProps,
    ...useLoadingProps,
    ...useMaxSelectionsProps,
    ...useClearableProps,
    ...useFormProps,
    ...useComponentPresetProp,
    modelValue: {
      type: [String, Number, Array, Object],
      default: ""
    },
    placement: {
      type: String,
      default: "bottom",
      validator: (placement) => ["top", "bottom"].includes(placement)
    },
    allowCreate: {
      type: [Boolean, String],
      default: false,
      validator: (mode) => [true, false, "unique"].includes(mode)
    },
    color: { type: String, default: "primary" },
    multiple: { type: Boolean, default: false },
    searchable: { type: Boolean, default: false },
    separator: { type: String, default: ", " },
    width: { type: String, default: "100%" },
    maxHeight: { type: String, default: "256px" },
    noOptionsText: { type: String, default: "$t:noOptions" },
    hideSelected: { type: Boolean, default: false },
    tabindex: { type: Number, default: 0 },
    dropdownIcon: {
      type: [String, Object],
      default: () => ({
        open: "va-arrow-down",
        close: "va-arrow-up"
      }),
      validator: (value) => {
        if (typeof value === "string") {
          return true;
        }
        const isOpenIconString = typeof value.open === "string";
        const isCloseIconString = typeof value.close === "string";
        return isOpenIconString && isCloseIconString;
      }
    },
    virtualScroller: { type: Boolean, default: false },
    outline: { type: Boolean, default: false },
    bordered: { type: Boolean, default: false },
    label: { type: String, default: "" },
    placeholder: { type: String, default: "" },
    searchPlaceholderText: { type: String, default: "$t:search" },
    requiredMark: { type: Boolean, default: false }
  },
  setup(props, { emit }) {
    const optionList = shallowRef();
    const input = shallowRef();
    const searchBar = shallowRef();
    const isInputFocused = useFocusDeep(input);
    const isFocused = computed(() => isInputFocused.value || showDropdownContent.value);
    const { getHoverColor, getColor } = useColors();
    const { getOptionByValue, getValue, getText, getTrackBy } = useSelectableList(props);
    const reset = () => withoutValidation(() => {
      if (props.multiple) {
        valueComputed.value = Array.isArray(props.clearValue) ? props.clearValue : [];
      } else {
        valueComputed.value = props.clearValue;
      }
      searchInput.value = "";
      emit("clear");
      resetValidation();
    });
    const focus = () => {
      var _a;
      if (props.disabled) {
        return;
      }
      (_a = input.value) == null ? void 0 : _a.focus();
    };
    const {
      validate,
      computedError,
      computedErrorMessages,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit, { reset, focus });
    const colorComputed = computed(() => getColor(props.color));
    const toggleIconColor = computed(() => props.readonly ? getHoverColor(colorComputed.value) : colorComputed.value);
    const onScrollBottom = () => emit("scroll-bottom");
    const searchInput = ref("");
    const showSearchInput = computed(() => props.searchable || props.allowCreate);
    watch(searchInput, (value) => {
      emit("update-search", value);
      hoveredOption.value = null;
    });
    const valueComputed = computed({
      get() {
        if (props.multiple) {
          if (!props.modelValue) {
            return [];
          }
          if (!Array.isArray(props.modelValue)) {
            return [getOptionByValue(props.modelValue)];
          }
          return props.modelValue.map(getOptionByValue);
        }
        const value = getOptionByValue(props.modelValue);
        if (Array.isArray(value)) {
          if (value.length) {
            return value[value.length - 1];
          }
        }
        return value;
      },
      set(value) {
        if (Array.isArray(value)) {
          emit("update:modelValue", value.map(getValue));
        } else {
          emit("update:modelValue", getValue(value));
        }
      }
    });
    const valueComputedString = computed(() => {
      if (!valueComputed.value && valueComputed.value !== 0) {
        return props.clearValue;
      }
      if (typeof valueComputed.value === "string" || typeof valueComputed.value === "number") {
        return valueComputed.value;
      }
      if (Array.isArray(valueComputed.value)) {
        return valueComputed.value.map((value) => getText(value)).join(props.separator) || props.clearValue;
      }
      return getText(valueComputed.value);
    });
    const isPlaceholder = computed(() => props.placeholder && !valueComputedString.value);
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props, valueComputed);
    const showClearIcon = computed(() => {
      if (!canBeCleared.value) {
        return false;
      }
      if (props.multiple && Array.isArray(valueComputed.value)) {
        return !!valueComputed.value.length;
      }
      return true;
    });
    const toggleIcon = computed(() => {
      if (!props.dropdownIcon) {
        return "";
      }
      if (typeof props.dropdownIcon === "string") {
        return props.dropdownIcon;
      }
      return showDropdownContent.value ? props.dropdownIcon.close : props.dropdownIcon.open;
    });
    const filteredOptions = computed(() => {
      if (!props.options) {
        return [];
      }
      if (props.hideSelected) {
        return props.options.filter((option) => !checkIsOptionSelected(option));
      }
      return props.options;
    });
    const checkIsOptionSelected = (option) => {
      if (!valueComputed.value) {
        return false;
      }
      if (Array.isArray(valueComputed.value)) {
        return !!valueComputed.value.find((valueItem) => compareOptions(valueItem, option));
      }
      return compareOptions(valueComputed.value, option);
    };
    const compareOptions = (option1, option2) => {
      const one = getValue(option1);
      const two = getValue(option2);
      if (one === two) {
        return true;
      }
      if (typeof one === "string" && typeof two === "string") {
        return one === two;
      }
      if (one === null || two === null) {
        return false;
      }
      if (typeof one === "object" && typeof two === "object") {
        return getTrackBy(one) === getTrackBy(two);
      }
      return false;
    };
    const isValueComputedArray = (v) => Array.isArray(v.value);
    const selectOption = (option) => {
      if (hoveredOption.value === null) {
        hideAndFocus();
        return;
      }
      if (showSearchInput.value) {
        searchInput.value = "";
      }
      if (props.multiple && isValueComputedArray(valueComputed)) {
        const { exceedsMaxSelections, addOption } = useMaxSelections(valueComputed, ref(props.maxSelections));
        const isSelected = checkIsOptionSelected(getValue(option));
        if (isSelected) {
          valueComputed.value = valueComputed.value.filter((optionSelected) => !compareOptions(getValue(option), getValue(optionSelected)));
        } else {
          if (exceedsMaxSelections()) {
            return;
          }
          valueComputed.value = addOption(option);
        }
      } else {
        valueComputed.value = typeof option === "string" || typeof option === "number" ? option : { ...option };
        hideAndFocus();
      }
    };
    const addNewOption = () => {
      var _a;
      const hasAddedOption = (_a = props.options) == null ? void 0 : _a.some((option) => getText(option) === searchInput.value);
      if (!(props.allowCreate === "unique" && hasAddedOption)) {
        emit("create-new", searchInput.value);
        searchInput.value = "";
      }
    };
    const hoveredOption = ref(null);
    const selectHoveredOption = () => {
      if (!hoveredOption.value && hoveredOption.value !== 0) {
        return;
      }
      if (!showDropdownContent.value) {
        showDropdown();
        return;
      }
      selectOption(hoveredOption.value);
    };
    const selectOrAddOption = () => {
      const allowedToCreate = !!props.allowCreate && searchInput.value !== "";
      if (hoveredOption.value !== null) {
        selectHoveredOption();
      } else if (allowedToCreate) {
        addNewOption();
      }
    };
    const focusPreviousOption = () => {
      var _a;
      return (_a = optionList.value) == null ? void 0 : _a.focusPreviousOption();
    };
    const focusNextOption = () => {
      var _a;
      return (_a = optionList.value) == null ? void 0 : _a.focusNextOption();
    };
    const showDropdownContent = ref(false);
    const showDropdownContentComputed = computed({
      get: () => showDropdownContent.value,
      set: (show) => {
        show ? showDropdown() : hideDropdown();
      }
    });
    const closeOnContentClick = computed(() => {
      return !(props.multiple || props.searchable || props.allowCreate);
    });
    const showDropdown = () => {
      if (props.disabled || props.readonly) {
        return;
      }
      showDropdownContent.value = true;
      scrollToSelected();
      focusSearchOrOptions();
    };
    const hideDropdown = () => {
      showDropdownContent.value = false;
      searchInput.value = "";
      validate();
    };
    const toggleDropdown = () => {
      if (showDropdownContent.value) {
        hideAndFocus();
      } else {
        showDropdown();
      }
    };
    const onSelectClick = () => {
      if (props.disabled || props.readonly) {
        return;
      }
      toggleDropdown();
    };
    const hideAndFocus = () => {
      hideDropdown();
      isInputFocused.value = true;
    };
    const focusSearchBar = () => {
      var _a;
      (_a = searchBar.value) == null ? void 0 : _a.focus();
    };
    const focusOptionList = () => {
      var _a, _b;
      (_a = optionList.value) == null ? void 0 : _a.focus();
      !props.modelValue && ((_b = optionList.value) == null ? void 0 : _b.focusFirstOption());
    };
    const focusSearchOrOptions = () => nextTick(() => {
      if (showSearchInput.value) {
        focusSearchBar();
      } else {
        focusOptionList();
      }
    });
    const onInputFocus = () => {
      isInputFocused.value = true;
      onFocus();
    };
    const onInputBlur = () => {
      if (showDropdownContentComputed.value) {
        return;
      }
      onBlur();
      isInputFocused.value ? isInputFocused.value = false : validate();
    };
    const blur = () => {
      var _a;
      if (showDropdownContentComputed.value) {
        showDropdownContentComputed.value = false;
      }
      nextTick((_a = input.value) == null ? void 0 : _a.blur);
    };
    const tabIndexComputed = computed(() => props.disabled ? -1 : props.tabindex);
    const scrollToSelected = () => {
      const selected = valueComputed.value;
      const nothingSelected = typeof selected !== "object" && Array.isArray(selected) && !selected.length;
      if (nothingSelected) {
        return;
      }
      const scrollTo = Array.isArray(selected) ? selected[selected.length - 1] : selected;
      hoveredOption.value = scrollTo;
      nextTick(() => {
        var _a;
        return (_a = optionList.value) == null ? void 0 : _a.scrollToOption(scrollTo);
      });
    };
    let hintedSearchQuery = "";
    let hintedSearchQueryTimeoutIndex;
    const navigationKeys = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Enter", " "];
    const onHintedSearch = (event) => {
      if (navigationKeys.some((key) => key === event.key)) {
        return;
      }
      const isLetter = event.key.length === 1;
      const isDeleteKey = event.key === "Backspace" || event.key === "Delete";
      clearTimeout(hintedSearchQueryTimeoutIndex);
      if (isDeleteKey) {
        hintedSearchQuery = hintedSearchQuery ? hintedSearchQuery.slice(0, -1) : "";
      } else if (isLetter) {
        hintedSearchQuery += event.key;
      }
      if (showSearchInput.value) {
        searchInput.value = hintedSearchQuery;
        return;
      }
      if (hintedSearchQuery) {
        const appropriateOption = props.options.find((option) => getText(option).toLowerCase().startsWith(hintedSearchQuery.toLowerCase()));
        if (appropriateOption) {
          hoveredOption.value = appropriateOption;
        }
      }
      hintedSearchQueryTimeoutIndex = setTimeout(() => {
        hintedSearchQuery = "";
      }, 1e3);
    };
    const { tp, t } = useTranslation();
    const dropdownPropsComputed = computed(() => ({
      ...filterComponentProps(VaDropdownProps).value,
      closeOnContentClick: closeOnContentClick.value,
      stateful: false,
      offset: [1, 0],
      keepAnchorWidth: true,
      keyboardNavigation: true,
      innerAnchorSelector: ".va-input-wrapper__field",
      "aria-label": props.modelValue ? `${t("selectedOption")}: ${props.modelValue}` : t("noSelectedOption")
    }));
    return {
      ...useTranslation(),
      isFocused,
      input,
      optionList,
      searchBar,
      reset,
      focus,
      blur,
      tp,
      onInputFocus,
      onInputBlur,
      focusOptionList,
      onSelectClick,
      focusSearchBar,
      searchInput,
      showSearchInput,
      hoveredOption,
      tabIndexComputed,
      valueComputed,
      valueComputedString,
      showClearIcon,
      toggleIcon,
      computedErrorMessages,
      computedError,
      filteredOptions,
      checkIsOptionSelected,
      selectOption,
      selectOrAddOption,
      selectHoveredOption,
      focusPreviousOption,
      focusNextOption,
      showDropdownContentComputed,
      showDropdown,
      hideDropdown,
      hideAndFocus,
      toggleDropdown,
      toggleIconColor,
      onHintedSearch,
      onScrollBottom,
      clearIconProps,
      isPlaceholder,
      dropdownPropsComputed
    };
  }
});
const _hoisted_1 = {
  key: 0,
  class: "va-select-anchor__placeholder"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_input_wrapper = resolveComponent("va-input-wrapper");
  const _component_va_input = resolveComponent("va-input");
  const _component_va_select_option_list = resolveComponent("va-select-option-list");
  const _component_va_dropdown_content = resolveComponent("va-dropdown-content");
  const _component_va_dropdown = resolveComponent("va-dropdown");
  return openBlock(), createBlock(_component_va_dropdown, mergeProps({
    ref: "dropdown",
    modelValue: _ctx.showDropdownContentComputed,
    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.showDropdownContentComputed = $event),
    class: "va-select va-select__dropdown va-select-dropdown"
  }, _ctx.dropdownPropsComputed, { onClose: _ctx.focus }), {
    anchor: withCtx(() => [
      createVNode(_component_va_input_wrapper, {
        ref: "input",
        class: "va-select__anchor va-select-anchor__input",
        "model-value": _ctx.valueComputedString,
        success: _ctx.$props.success,
        error: _ctx.computedError,
        color: _ctx.$props.color,
        label: _ctx.$props.label,
        loading: _ctx.$props.loading,
        outline: _ctx.$props.outline,
        bordered: _ctx.$props.bordered,
        "required-mark": _ctx.$props.requiredMark,
        messages: _ctx.$props.messages,
        "error-messages": _ctx.computedErrorMessages,
        focused: _ctx.isFocused,
        tabindex: _ctx.tabIndexComputed,
        onFocus: _ctx.onInputFocus,
        onBlur: _ctx.onInputBlur
      }, createSlots({
        icon: withCtx(() => [
          _ctx.showClearIcon ? (openBlock(), createBlock(_component_va_icon, mergeProps({
            key: 0,
            role: "button",
            "aria-label": _ctx.t("reset"),
            tabindex: "0"
          }, _ctx.clearIconProps, {
            onClick: withModifiers(_ctx.reset, ["stop"]),
            onKeydown: [
              withKeys(withModifiers(_ctx.reset, ["stop"]), ["enter"]),
              withKeys(withModifiers(_ctx.reset, ["stop"]), ["space"])
            ]
          }), null, 16, ["aria-label", "onClick", "onKeydown"])) : createCommentVNode("", true)
        ]),
        appendInner: withCtx(() => [
          _ctx.$slots.appendInner ? renderSlot(_ctx.$slots, "appendInner", { key: 0 }) : createCommentVNode("", true),
          createVNode(_component_va_icon, {
            color: _ctx.toggleIconColor,
            name: _ctx.toggleIcon
          }, null, 8, ["color", "name"])
        ]),
        default: withCtx(() => [
          _ctx.isPlaceholder ? (openBlock(), createElementBlock("span", _hoisted_1, toDisplayString(_ctx.$props.placeholder), 1)) : renderSlot(_ctx.$slots, "content", normalizeProps(mergeProps({ key: 1 }, {
            valueString: _ctx.valueComputedString,
            value: _ctx.valueComputed,
            tabindex: _ctx.tabIndexComputed
          })), () => [
            createTextVNode(toDisplayString(_ctx.valueComputedString), 1)
          ])
        ]),
        _: 2
      }, [
        _ctx.$slots.prepend ? {
          name: "prepend",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "prepend")
          ])
        } : void 0,
        _ctx.$slots.append ? {
          name: "append",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "append")
          ])
        } : void 0,
        _ctx.$slots.prependInner ? {
          name: "prependInner",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "prependInner")
          ])
        } : void 0
      ]), 1032, ["model-value", "success", "error", "color", "label", "loading", "outline", "bordered", "required-mark", "messages", "error-messages", "focused", "tabindex", "onFocus", "onBlur"])
    ]),
    default: withCtx(() => [
      createVNode(_component_va_dropdown_content, {
        class: "va-select-dropdown__content",
        style: normalizeStyle({ width: _ctx.$props.width })
      }, {
        default: withCtx(() => [
          _ctx.showSearchInput ? (openBlock(), createBlock(_component_va_input, {
            key: 0,
            ref: "searchBar",
            class: "va-select-dropdown__content-search-input",
            "aria-label": _ctx.t("optionsFilter"),
            tabindex: _ctx.tabIndexComputed,
            bordered: true,
            placeholder: _ctx.tp(_ctx.$props.searchPlaceholderText),
            modelValue: _ctx.searchInput,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.searchInput = $event),
            onKeydown: [
              withKeys(withModifiers(_ctx.focusPreviousOption, ["stop", "prevent"]), ["up"]),
              withKeys(withModifiers(_ctx.focusPreviousOption, ["stop", "prevent"]), ["left"]),
              withKeys(withModifiers(_ctx.focusNextOption, ["stop", "prevent"]), ["down"]),
              withKeys(withModifiers(_ctx.focusNextOption, ["stop", "prevent"]), ["right"]),
              withKeys(withModifiers(_ctx.selectOrAddOption, ["prevent"]), ["enter"])
            ],
            onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.hoveredOption = null)
          }, null, 8, ["aria-label", "tabindex", "placeholder", "modelValue", "onKeydown"])) : createCommentVNode("", true),
          createVNode(_component_va_select_option_list, {
            ref: "optionList",
            class: "va-select-dropdown__options-wrapper",
            hoveredOption: _ctx.hoveredOption,
            "onUpdate:hoveredOption": _cache[2] || (_cache[2] = ($event) => _ctx.hoveredOption = $event),
            style: normalizeStyle({ maxHeight: _ctx.$props.maxHeight }),
            options: _ctx.filteredOptions,
            "selected-value": _ctx.valueComputed,
            "get-selected-state": _ctx.checkIsOptionSelected,
            "text-by": _ctx.$props.textBy,
            "track-by": _ctx.$props.trackBy,
            "group-by": _ctx.$props.groupBy,
            "disabled-by": _ctx.$props.disabledBy,
            search: _ctx.searchInput,
            "no-options-text": _ctx.tp(_ctx.$props.noOptionsText),
            color: _ctx.$props.color,
            tabindex: _ctx.tabIndexComputed,
            "virtual-scroller": _ctx.$props.virtualScroller,
            onSelectOption: _ctx.selectOption,
            onNoPreviousOptionToHover: _ctx.focusSearchBar,
            onKeydown: [
              withKeys(withModifiers(_ctx.selectHoveredOption, ["stop", "prevent"]), ["enter"]),
              withKeys(withModifiers(_ctx.selectHoveredOption, ["stop", "prevent"]), ["space"]),
              _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => _ctx.searchBar && _ctx.searchBar.focus(), ["stop", "prevent"]), ["tab"])),
              _ctx.onHintedSearch
            ],
            onScrollBottom: _ctx.onScrollBottom
          }, {
            default: withCtx((slotData) => [
              renderSlot(_ctx.$slots, "option", normalizeProps(guardReactiveProps(slotData || {})))
            ]),
            _: 3
          }, 8, ["hoveredOption", "style", "options", "selected-value", "get-selected-state", "text-by", "track-by", "group-by", "disabled-by", "search", "no-options-text", "color", "tabindex", "virtual-scroller", "onSelectOption", "onNoPreviousOptionToHover", "onKeydown", "onScrollBottom"])
        ]),
        _: 3
      }, 8, ["style"])
    ]),
    _: 3
  }, 16, ["modelValue", "onClose"]);
}
var _VaSelect = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { _VaSelect as _ };
//# sourceMappingURL=VaSelect.mjs.map
